<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,maximum-scale=2,viewport-fit=cover"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><meta name="author" content="Simon Ma"><link rel="icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/favicon.ico"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/favicon.ico"><link rel="apple-touch-icon" href="https://cdn.jsdelivr.net/gh/Tomotoes/images/PWA/apple-touch-icon.png"><title>Go 开发中的十大常见陷阱[译]</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/font/comic.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-roboto@1.1.13/index.min.css"><link id="style" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/style-37d854d498.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/post-3566510171.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/module/relatedPosts-25786aa404.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/module/comment-bfd02bb730.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/module/reward-fc1e0c7470.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/firacode@5.2.0/distr/fira_code.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/highlight-271688128f.css"><meta name="theme-color"><meta name="apple-mobile-web-app-status-bar-style"><meta name="msapplication-navbutton-color"><script>
	window.selectedColor = ''
	window.themeColor = localStorage.getItem("theme-color") || "#7af"
	window.changeColor = function(themeColor){
		document.documentElement.style.setProperty('--theme-color', themeColor);
		document.querySelector("meta[name=theme-color]").setAttribute("content", themeColor);
		document.querySelector("meta[name=apple-mobile-web-app-status-bar-style]").setAttribute("content", themeColor);
		document.querySelector("meta[name=msapplication-navbutton-color]").setAttribute("content", themeColor);
		localStorage.setItem('theme-color', themeColor)
	}
	changeColor(themeColor)

	window.isPhone = /Android|iOS|iPhone|iPad|iPod|Windows Phone|KFAPWI/i.test(navigator.userAgent) || (window.innerWidth <= 1370)
	window.isHome = false
	window.isPost = true
	if(window.isPost){
		window.isReward = true
	}
</script><link rel="manifest" href="https://tomotoes.com/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="mobile-web-app-title" content="一个坏掉的番茄"><meta name="msapplication-starturl" content="https://tomotoes.com"><meta name="application-name" content="一个坏掉的番茄"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="一个坏掉的番茄"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="prefetch" href="https://cdn.jsdelivr.net/"><link rel="dns-prefetch" href="https://api.github.com/"><link rel="dns-prefetch" href="https://disqus.com"><link rel="dns-prefetch" href="https://tomotoes-com.disqus.com"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-109696496-3"></script><script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'UA-109696496-3');
</script><link rel="canonical" href="https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/"><link rel="alternate" type="application/atom+xml" title="一个坏掉的番茄" href="/blog/atom.xml"><meta property="og:title" content="Go 开发中的十大常见陷阱[译] | 一个坏掉的番茄"><meta property="og:site_name" content="一个坏掉的番茄"><meta property="og:type" content="article"><meta property="og:url" content="https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/"><meta property="og:locale" content="zh-CN"><meta name="description" content="Go开发中的十大常见陷阱 - Simon Ma - 一个坏掉的番茄"><meta name="keywords" content="Go 中的陷阱与错误,Go 语言规范,后端,Go,译文,一个坏掉的番茄,Blog,博客,Tomotoes,SimonMa,SimonAKing,Codenter,jinma,马寂寞"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Tomotoes/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/permit.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Tomotoes/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/1.jpeg"><meta property="article:published_time" content="2019-08-17T09:26:05.000Z"><meta property="article:modified_time" content="2021-02-14T17:22:36.312Z"><meta property="og:updated_time" content="2021-02-14T17:22:36.312Z"><meta property="article:author" content="Simon Ma"><meta property="article:tag" content="Go 中的陷阱与错误,Go 语言规范,后端,Go,译文,一个坏掉的番茄,Blog,博客,Tomotoes,SimonMa,SimonAKing,Codenter,jinma,马寂寞"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="https:&#x2F;&#x2F;tomotoes.com&#x2F;blog&#x2F;the-top-10-most-common-mistakes-ive-seen-in-go-projects&#x2F;"><meta name="twitter:creator" content="Simon Ma"><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/",
    "@type": "BlogPosting",
    "logo": "https://tomotoes.com/images/PWA/192.png",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/"
    },
    "headline": "Go 开发中的十大常见陷阱[译] | 一个坏掉的番茄",
    "image": {
        "@type": "ImageObject",
        "url": "https://tomotoes.com/images/PWA/192.png"
    },
    "datePublished": "2019-08-17T09:26:05.000Z",
    "dateModified": "2021-02-14T17:22:36.312Z",
    "author": {
        "@type": "Person",
        "name": "Simon Ma",
        "image": {
            "@type": "ImageObject",
            "url": "https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/avatar.jpg"
        },
        "description": "Input &amp; Think &amp; Output"
    },
    "publisher": {
        "@type": "Organization",
        "name": "一个坏掉的番茄",
        "logo": {
            "@type": "ImageObject",
            "url": "https://tomotoes.com/images/PWA/192.png"
        }
    },
    "keywords": "Go 中的陷阱与错误,Go 语言规范,后端,Go,译文,一个坏掉的番茄,Blog,博客,Tomotoes,SimonMa,SimonAKing,Codenter,jinma,马寂寞",
    "description": "Go开发中的十大常见陷阱 - Simon Ma - 一个坏掉的番茄"
}
</script><!--[if lt IE 9]><style> .alert { padding: 15px; margin-bottom: 20px; border: 1px solid transparent; border-radius: 4px } .alert-danger { background-color: #f2dede; border-color: #ebccd1; color: #a94442; border-bottom: 1px solid #ebccd1 } .alert-link { color: #843534; font-weight: bold } .topframe { margin: 0; padding-left: 15px; padding-right: 15px; text-align: center; border-radius: 0; position: fixed; left: 0; right: 0; top: 0; z-index: 1000 } </style><div class="alert alert-danger topframe"> 你的浏览器实在<strong>太太太太太太旧了</strong>，放学别走，升级完浏览器再说！ <a target="_blank" class="alert-link" href="//browsehappy.com">立即升级</a></div><script src="https://cdn.bootcss.com/html5shiv/r29/html5.min.js"></script><script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script><![endif]--></head><body itemscope itemtype="http://schema.org/WebPage"><aside id="menu" class="hide"><div class="inner flex-row-vertical"><div class="brand-wrap" itemprop="author" itemscope itemtype="http://schema.org/Person"><div class="brand fade"> <a class="avatar waves-effect waves-circle waves-light"><img src="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/avatar.jpg" title="avatar" alt="avatar" itemprop="image"></a><div class="introduce"><h5 class="nickname " id="name">Simon Ma</h5><div class="links-of-author fade"> <span class="links-of-author-item"><a href="https://github.com/Tomotoes" rel="external nofollow noopener noreferrer" target="_blank" title="Github"><i class="icon icon-lg icon-github"><span>Tomotoes</span></i></a></span> <span class="links-of-author-item"><a href="https://twitter.com/simon_aking" rel="external nofollow noopener noreferrer" target="_blank" title="Twitter"><i class="icon icon-lg icon-twitter"><span>SimonAKing</span></i></a></span> <span class="links-of-author-item"><a href="https://t.me/tomotoes" rel="external nofollow noopener noreferrer" target="_blank" title="TG频道"><i class="icon icon-lg icon-telegram"><span>TG频道</span></i></a></span></div><div class="statistics"><ul><li><a class="total-link" href="/blog/weibo/"><div class="count" id="weibo-count">∞</div><div class="type">微博</div></a></li><li><a class="total-link" href="/blog/archives/"><div class="count">37</div><div class="type">文章</div></a></li><li><a class="total-link" href="/gallery/"><div class="count" id="photo-count">∞</div><div class="type">相册</div></a></li></ul></div></div></div></div><div class="scroll-wrap flex-col"><ul class="nav fade"><li class="items waves-block waves-effect"><a href="/blog/"><i class="icon icon-lg icon-xiazai45"></i> <span style="font-size:1em">主 页</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="/blog/archives/"><i class="icon icon-lg icon-guidangxiangmu"></i> <span style="font-size:1em">归 档</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="/blog/tags/"><i class="icon icon-lg icon-biaoqian"></i> <span style="font-size:1em">标 签</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="/blog/weibo/"><i class="icon icon-lg icon-biaoqing"></i> <span style="font-size:1em">微 博</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//tomotoes.com/gallery/"><i class="icon icon-lg icon-xiangce"></i> <span style="font-size:1em">相 册</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//thinking.tomotoes.com/" target="_blank" rel="noopener"><i class="icon icon-lg icon--Idea"></i> <span style="font-size:1em">阅 读</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//tomotoes.com/about/"><i class="icon icon-lg icon-zhifeiji"></i> <span style="font-size:1em">关 于</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//tomotoes.com"><i class="icon icon-lg icon-icon--"></i> <span style="font-size:1em">导航</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><div class="sliding-bar"></div></ul><div class="nav-tool"><a class="nav-tool-item exchange" data-title="简繁互换" href="javascript:translatePage();"><i class="fade icon icon-lg icon-zhuanhuan custom-exchange"></i></a><a class="nav-tool-item picker" data-title="调色板" id="color-picker-icon"><i class="fade icon icon-lg icon-color-palette-outlin custom-picker"></i></a><a class="nav-tool-item light" data-title="关灯" href="javascript:switchNightMode();"><i class="fade icon icon-lg icon-lightbulbo custom-lightbulb"></i></a></div></div></div></aside><main id="main"><header class="top-header" id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-naviconround"></i></a><div class="flex-col header-title ellipsis">Go 开发中的十大常见陷阱[译]</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevronleft"></i></a> <input type="text" id="key" aria-label="search" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" title="搜索" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div></div></header><header class="content-header post-header"></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap fade" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#正文"><span class="post-toc-number">2.</span> <span class="post-toc-text">正文</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#未知的枚举值"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">未知的枚举值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#自动优化的基准测试"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">自动优化的基准测试</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#延伸阅读"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">延伸阅读</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#被转移的指针"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">被转移的指针</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#延伸阅读-1"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">延伸阅读</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#出乎意料的-break"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">出乎意料的 break</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#缺失上下文的错误"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">缺失上下文的错误</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#延伸阅读-2"><span class="post-toc-number">2.5.1.</span> <span class="post-toc-text">延伸阅读</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#正在扩容的切片"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">正在扩容的切片</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#无规范的-Context"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">无规范的 Context</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#延伸阅读-3"><span class="post-toc-number">2.7.1.</span> <span class="post-toc-text">延伸阅读</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#被遗忘的-race-参数"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">被遗忘的-race 参数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#延伸阅读-4"><span class="post-toc-number">2.8.1.</span> <span class="post-toc-text">延伸阅读</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#更完美的封装"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">更完美的封装</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Goruntines-与循环变量"><span class="post-toc-number">2.10.</span> <span class="post-toc-text">Goruntines 与循环变量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#延伸阅读-5"><span class="post-toc-number">2.10.1.</span> <span class="post-toc-text">延伸阅读</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结束语"><span class="post-toc-number">3.</span> <span class="post-toc-text">结束语</span></a></li></ol></nav></aside><article id="post-Go开发中的十大常见陷阱-译" class="post-article article-type-post fade" itemscope itemtype="http://schema.org/Article"><div class="post-card"><h1 class="post-card-title" itemprop="name headline">&nbsp;</h1><script>
			window.addEventListener('DOMContentLoaded', function (){ var postTitle = document.querySelector('.post-card-title'); var typingbefore = 'Go 开发中的十大常见陷阱[译]'; var _i = 0; function typetitle() { if (_i <= typingbefore.length) { postTitle.innerHTML = `${typingbefore.slice(0, _i++)}|`; setTimeout(typetitle, 120); } else { postTitle.innerHTML = typingbefore; } } typetitle(); })
		</script><div class="post-meta"><div class="post-category-phone"><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul></div> <time itemprop="dateCreated datePublished" class="post-time" title="2019-08-17 17:26:05" datetime="2019-08-17T09:26:05.000Z">2019-08-17</time></div><div class="post-category" itemprop="about" itemscope itemtype="http://schema.org/Thing"><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul></div><div class="post-count-custom"><i class="icon icon-lg icon-commenting-o"></i> 阅读本文可能花费您&nbsp;<span class="post-count">16</span>&nbsp;分钟</div><link itemprop="mainEntityOfPage" href="https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/" style="display:none"><div class="post-content" id="post-content" itemprop="articleBody"><p>Golang 中要注意的陷阱和常见错误。<a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文: <a href="https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65#e9ba" target="_blank" rel="external nofollow noopener noreferrer">The Top 10 Most Common Mistakes I’ve Seen in Go Projects</a></p><p>作者: <a href="https://itnext.io/@teivah?source=post_page-----4b79d4f6cd65----------------------" target="_blank" rel="external nofollow noopener noreferrer">Teiva Harsanyi</a></p><p>翻译许可:</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/Tomotoes/images/loading/1-min.gif" alt="image-20210118234116954" title data-original="https://cdn.jsdelivr.net/gh/Tomotoes/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/permit.png"></div><div class="image-caption">image-20210118234116954</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/Tomotoes/images/loading/1-min.gif" alt="img" title data-original="https://cdn.jsdelivr.net/gh/Tomotoes/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/1.jpeg"></div><div class="image-caption">img</div></figure><p>我在 Go 开发中遇到的十大常见错误。<em>顺序无关紧要。</em></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="未知的枚举值"><a href="#未知的枚举值" class="headerlink" title="未知的枚举值"></a>未知的枚举值</h3><p>让我们看一个简单的例子:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Status <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusOpen Status = <span class="literal">iota</span></span><br><span class="line">  StatusClosed</span><br><span class="line">  StatusUnknown</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>在这里，我们使用 iota 创建了一个枚举，其结果如下：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">StatusOpen</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">StatusClosed</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">StatusUnknown</span> = <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>现在，让我们假设这个<code>Status</code>类型是 JSON 请求的一部分，将被<code>marshalled/unmarshalled</code>。</p><p>我们设计了以下结构：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> {</span><br><span class="line">  ID        <span class="keyword">int</span>    <span class="string">`json:"Id"`</span></span><br><span class="line">  Timestamp <span class="keyword">int</span>    <span class="string">`json:"Timestamp"`</span></span><br><span class="line">  Status    Status <span class="string">`json:"Status"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后，接收这样的请求：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"Id"</span>: <span class="number">1234</span>,</span><br><span class="line">  <span class="attr">"Timestamp"</span>: <span class="number">1563362390</span>,</span><br><span class="line">  <span class="attr">"Status"</span>: <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里没有什么特别的，状态会被<code>unmarshalled</code>为<code>StatusOpen</code>。</p><p>然而，让我们以另一个未设置状态值的请求为例:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"Id"</span>: <span class="number">1235</span>,</span><br><span class="line">  <span class="attr">"Timestamp"</span>: <span class="number">1563362390</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这种情况下，请求结构的<code>Status</code>字段将初始化为它的零值(对于<code>uint32</code>类型:0)，因此结果将是<code>StatusOpen</code>而不是<code>StatusUnknown</code>。</p><p>那么最好的做法是<strong>将枚举的未知值设置为 0</strong>：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Status <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusUnknown Status = <span class="literal">iota</span></span><br><span class="line">  StatusOpen</span><br><span class="line">  StatusClosed</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>如果状态不是 JSON 请求的一部分，它将被初始化为<code>StatusUnknown</code>，这才符合我们的期望。</p><h3 id="自动优化的基准测试"><a href="#自动优化的基准测试" class="headerlink" title="自动优化的基准测试"></a>自动优化的基准测试</h3><p>基准测试需要考虑很多因素的,才能得到正确的测试结果。</p><p>一个常见的错误是<strong>测试代码无形间被编译器所优化</strong>。</p><p>下面是<code>teivah/bitvector</code>库中的一个例子:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">(n <span class="keyword">uint64</span>, i, j <span class="keyword">uint8</span>)</span> <span class="title">uint64</span></span> {</span><br><span class="line">  <span class="keyword">return</span> (math.MaxUint64&lt;&lt;j | ((<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>)) &amp; n</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此函数清除给定范围内的位。为了测试它，可能如下这样做:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkWrong</span><span class="params">(b *testing.B)</span></span> {</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ {</span><br><span class="line">    clear(<span class="number">1221892080809121</span>, <span class="number">10</span>, <span class="number">63</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个基准测试中，<code>clear</code>不调用任何其他函数，没有<strong>副作用</strong>。所以编译器将会把<code>clear</code>优化成内联函数。一旦内联，将会导致不准确的测试结果。</p><p>一个解决方案是<strong>将函数结果设置为全局变量</strong>，如下所示：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCorrect</span><span class="params">(b *testing.B)</span></span> {</span><br><span class="line">  <span class="keyword">var</span> r <span class="keyword">uint64</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ {</span><br><span class="line">    r = clear(<span class="number">1221892080809121</span>, <span class="number">10</span>, <span class="number">63</span>)</span><br><span class="line">  }</span><br><span class="line">  result = r</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如此一来，编译器将不知道<code>clear</code>是否会产生副作用。</p><p>因此，不会将<code>clear</code>优化成内联函数。</p><h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p><a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html?source=post_page-----4b79d4f6cd65----------------------#watch_out_for_compiler_optimisations" target="_blank" rel="external nofollow noopener noreferrer">High Performance Go Workshop</a></p><h3 id="被转移的指针"><a href="#被转移的指针" class="headerlink" title="被转移的指针"></a>被转移的指针</h3><p>在函数调用中，按值传递的变量将创建该变量的副本，而通过指针传递只会传递该变量的内存地址。</p><p>那么，指针传递会比按值传递更快吗？请看一下<a href="https://gist.github.com/teivah/a32a8e9039314a48f03538f3f9535537" target="_blank" rel="external nofollow noopener noreferrer">这个例子</a>。</p><p>我在本地环境上模拟了<code>0.3KB</code>的数据，然后分别测试了按值传递和指针传递的速度。</p><p>结果显示：按值传递比指针传递快 4 倍以上，这很违背直觉。</p><p>测试结果与 Go 中如何管理内存有关。我虽然不能像<a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html" target="_blank" rel="external nofollow noopener noreferrer">威廉·肯尼迪</a>那样出色地解释它，但让我试着总结一下。</p><p>译者注开始</p><p>作者没有说明 Go 内存的基本存储方式，译者补充一下。</p><ol><li><p>下面是来自 Go 语言圣经的介绍：</p><p>一个 goroutine 会以一个很小的栈开始其生命周期，一般只需要 2KB。</p><p>一个 goroutine 的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和 OS 线程不太一样的是，一个 goroutine 的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。</p><p>而 goroutine 的栈的最大值有 1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多 goroutine 都不需要这么大的栈。</p></li><li><p>译者自己的理解：</p><ul><li><p>栈：每个 Goruntine 开始的时候都有独立的栈来存储数据。（<em>Goruntine 分为主 Goruntine 和其他 Goruntine，差异就在于起始栈的大小</em>）</p></li><li><p>堆: 而需要被多个 Goruntine 共享的数据，存储在堆上面。</p></li></ul></li></ol><p>译者注结束</p><p>众所周知，可以在<strong>堆</strong>或<strong>栈</strong>上分配变量。</p><ul><li>栈储存当前<code>Goroutine</code>的正在使用的变量（译者注: 可理解为局部变量）。一旦函数返回，变量就会从栈中弹出。</li><li>堆储存<strong>共享变量</strong>（全局变量等）。</li></ul><p>让我们看一个简单的例子，返回单一的值：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFooValue</span><span class="params">()</span> <span class="title">foo</span></span> {</span><br><span class="line">  <span class="keyword">var</span> result foo</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当调用函数时，<code>result</code>变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一份值的拷贝。而<code>result</code>变量自身会从当前 Goruntine 栈出栈。</p><p>虽然它仍然存在于内存中，但它不能再被访问。并且还有可能被其他数据变量所擦除。</p><p>现在，在看一个返回指针的例子：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFooPointer</span><span class="params">()</span> *<span class="title">foo</span></span> {</span><br><span class="line">  <span class="keyword">var</span> result foo</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">  <span class="keyword">return</span> &amp;result</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当调用函数时，<code>result</code>变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一个指针（变量地址的副本）。如果<code>result</code>变量从当前 Goruntine 栈出栈，则接收者将无法再访问它。（译者注：此情况称为“内存逃逸”）</p><p>在这个场景中，Go 编译器将把<code>result</code>变量<strong>转义</strong>到一个可以共享变量的地方:<strong>堆</strong>。</p><p>不过，传递指针是另一种情况。例如：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {</span><br><span class="line">  p := &amp;foo{}</span><br><span class="line">  f(p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为我们在同一个 Goroutine 中调用<code>f</code>，所以<code>p</code>变量不需要转义。它只是被推送到堆栈，子功能可以访问它。（译者注：不需要其他 Goruntine 共享的变量就存储在栈上即可）</p><p>比如，<code>io.Reader</code>中的<code>Read</code>方法签名，接收切片参数，将内容读取到切片中，返回读取的字节数。而不是返回读取后的切片。（译者注：如果返回切片，会将切片转义到堆中。）</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> {</span><br><span class="line">  Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为什么栈如此之快？ 主要有两个原因：</p><ol><li><strong>堆栈不需要垃圾收集器。</strong>就像我们说的，变量一旦创建就会被入栈，一旦函数返回就会从出栈。不需要一个复杂的进程来回收未使用的变量。</li><li><strong>储存变量不需要考虑同步。</strong>堆属于一个 Goroutine，因此与在堆上存储变量相比，存储变量不需要同步。</li></ol><p>总之，当创建一个函数时，我们的<strong>默认行为应该是使用值</strong>而不是指针。只有在我们<strong>想要共享变量时才应使用指针。</strong></p><p>如果我们遇到性能问题，可以使用<code>go build -gcflags "-m -m"</code>命令，来显示编译器将变量转义到堆的具体操作。</p><p>再次重申，对于大多数日常用例来说，值传递是最合适的。</p><h4 id="延伸阅读-1"><a href="#延伸阅读-1" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><ol><li><p><a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html?source=post_page-----4b79d4f6cd65----------------------" target="_blank" rel="external nofollow noopener noreferrer">Language Mechanics On Stacks And Pointers</a></p></li><li><p><a href="https://www.youtube.com/watch?v=ZMZpH4yT7M0" target="_blank" rel="external nofollow noopener noreferrer">Understanding Allocations: the Stack and the Heap - GopherCon SG 2019</a></p></li></ol><h3 id="出乎意料的-break"><a href="#出乎意料的-break" class="headerlink" title="出乎意料的 break"></a>出乎意料的 break</h3><p>如果<code>f</code>返回 true，下面的例子中会发生什么？</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> {</span><br><span class="line">  <span class="keyword">switch</span> f() {</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们将调用<code>break</code>语句。然而，将会<code>break</code>出<code>switch</code>语句，而不是<code>for</code>循环。</p><p>同样的问题：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> {</span><br><span class="line">  <span class="keyword">select</span> {</span><br><span class="line">  <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">  <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>break</code>与<code>select</code>语句有关，与<code>for</code>循环无关。</p><p><code>break</code>出<code>for/switch 或 for/select</code>的一种解决方案是<strong>使用带标签的 break</strong>，如下所示：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">  <span class="keyword">for</span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      <span class="keyword">break</span> loop</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="缺失上下文的错误"><a href="#缺失上下文的错误" class="headerlink" title="缺失上下文的错误"></a>缺失上下文的错误</h3><p>Go 在错误处理方面仍然有待提高，以至于现在错误处理是 Go2 中最令人期待的需求。</p><p>当前的标准库(在 Go 1.13 之前)只提供<code>error</code>的构造函数，自然而然就会缺失其他信息。</p><p>让我们看一下<a href="https://github.com/pkg/errors" target="_blank" rel="external nofollow noopener noreferrer">pkg/errors</a>库中错误处理的思想：</p><p><em>An error should be handled only</em> <strong>once</strong>. Logging an error <strong>is</strong> <em>handling an error. So an error should</em> <strong>either</strong> <em>be logged or propagated.</em></p><p>（译：错误应该只处理一次。记录<em>log</em> 错误就是在处理错误。所以，错误应该记录或者传播）</p><p>对于当前的标准库，很难做到这一点，因为我们希望向错误中添加一些上下文信息，使其具有层次结构。</p><p>例如: 所期望的<code>REST</code>调用导致数据库问题的示例：</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unable <span class="keyword">to</span><span class="built_in"> server </span>HTTP POST request <span class="keyword">for</span><span class="built_in"> customer </span>1234</span><br><span class="line"> |_ unable <span class="keyword">to</span> insert<span class="built_in"> customer </span>contract abcd</span><br><span class="line">     |_ unable <span class="keyword">to</span> commit transaction</span><br></pre></td></tr></tbody></table></figure><p>如果我们使用<code>pkg/errors</code>，可以这样做：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postHandler</span><span class="params">(customer Customer)</span> <span class="title">Status</span></span> {</span><br><span class="line">  err := insert(customer.Contract)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    log.WithError(err).Errorf(<span class="string">"unable to server HTTP POST request for customer %s"</span>, customer.ID)</span><br><span class="line">    <span class="keyword">return</span> Status{ok: <span class="literal">false</span>}</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Status{ok: <span class="literal">true</span>}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(contract Contract)</span> <span class="title">error</span></span> {</span><br><span class="line">  err := dbQuery(contract)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> errors.Wrapf(err, <span class="string">"unable to insert customer contract %s"</span>, contract.ID)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dbQuery</span><span class="params">(contract Contract)</span> <span class="title">error</span></span> {</span><br><span class="line">  <span class="comment">// Do something then fail</span></span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"unable to commit transaction"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果不是由外部库返回的初始<code>error</code>可以使用<code>error.New</code>创建。中间层<code>insert</code>对此错误添加更多上下文信息。最终通过<code>log</code>错误来处理错误。每个级别要么返回错误，要么处理错误。</p><p>我们可能还想检查错误原因来判读是否应该重试。假设我们有一个来自外部库的<code>db</code>包来处理数据库访问。 该库可能会返回一个名为<code>db.DBError</code>的临时错误。要确定是否需要重试，我们必须检查错误原因：</p><p>使用<code>pkg/errors</code>中提供的<code>errors.Cause</code>可以判断错误原因。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postHandler</span><span class="params">(customer Customer)</span> <span class="title">Status</span></span> {</span><br><span class="line">  err := insert(customer.Contract)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">switch</span> errors.Cause(err).(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      log.WithError(err).Errorf(<span class="string">"unable to server HTTP POST request for customer %s"</span>, customer.ID)</span><br><span class="line">      <span class="keyword">return</span> Status{ok: <span class="literal">false</span>}</span><br><span class="line">    <span class="keyword">case</span> *db.DBError:</span><br><span class="line">      <span class="keyword">return</span> retry(customer)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Status{ok: <span class="literal">true</span>}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(contract Contract)</span> <span class="title">error</span></span> {</span><br><span class="line">  err := db.dbQuery(contract)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> errors.Wrapf(err, <span class="string">"unable to insert customer contract %s"</span>, contract.ID)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我见过的一个常见错误是部分使用<code>pkg/errors</code>。 例如，通过这种方式检查错误：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> err.(<span class="keyword">type</span>) {</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  log.WithError(err).Errorf(<span class="string">"unable to server HTTP POST request for customer %s"</span>, customer.ID)</span><br><span class="line">  <span class="keyword">return</span> Status{ok: <span class="literal">false</span>}</span><br><span class="line"><span class="keyword">case</span> *db.DBError:</span><br><span class="line">  <span class="keyword">return</span> retry(customer)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在此示例中，如果<code>db.DBError</code>被<code>wrapped</code>，它将永远不会执行<code>retry</code>。</p><h4 id="延伸阅读-2"><a href="#延伸阅读-2" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully?source=post_page-----4b79d4f6cd65----------------------" target="_blank" rel="external nofollow noopener noreferrer">Don’t just check errors, handle them gracefully</a></p><h3 id="正在扩容的切片"><a href="#正在扩容的切片" class="headerlink" title="正在扩容的切片"></a>正在扩容的切片</h3><p>有时，我们知道切片的最终长度。假设我们想把<code>Foo</code>切片转换成<code>Bar</code>切片，这意味着这两个切片的长度是一样的。</p><p>我经常看到切片以下面的方式初始化：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bars []Bar</span><br><span class="line">bars := <span class="built_in">make</span>([]Bar, <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><p>切片不是一个神奇的数据结构，如果没有更多可用空间，它会进行双倍扩容。在这种情况下，会自动创建一个切片(容量更大)，并复制其中的元素。</p><p>如果想容纳上千个元素，想象一下，我们需要扩容多少次。虽然插入的时间复杂度是<code>O(1)</code>，但它仍会对性能有所影响。</p><p>因此，如果我们知道最终长度，我们可以:</p><ul><li><p>用预定义的长度初始化它</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(foos []Foo)</span> []<span class="title">Bar</span></span> {</span><br><span class="line">  bars := <span class="built_in">make</span>([]Bar, <span class="built_in">len</span>(foos))</span><br><span class="line">  <span class="keyword">for</span> i, foo := <span class="keyword">range</span> foos {</span><br><span class="line">    bars[i] = fooToBar(foo)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> bars</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>或者使用长度 0 和预定义容量初始化它：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(foos []Foo)</span> []<span class="title">Bar</span></span> {</span><br><span class="line">  bars := <span class="built_in">make</span>([]Bar, <span class="number">0</span>, <span class="built_in">len</span>(foos))</span><br><span class="line">  <span class="keyword">for</span> _, foo := <span class="keyword">range</span> foos {</span><br><span class="line">    bars = <span class="built_in">append</span>(bars, fooToBar(foo))</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> bars</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="无规范的-Context"><a href="#无规范的-Context" class="headerlink" title="无规范的 Context"></a>无规范的 Context</h3><p><code>context.Context</code> 经常被误用。 根据官方文档:</p><blockquote><p><em>A Context carries a deadline, a cancelation signal, and other values across API boundaries.</em></p></blockquote><p>这种描述非常笼统，以至于让一些人对使用它感到困惑。</p><p>让我们试着详细描述一下。<code>Context</code>可以包含:</p><ul><li>A <strong>deadline</strong>（最后期限）。它意味着到期之后（250ms 之后或者一个指定的日期），我们必须停止正在进行的操作（<code>I/O</code>请求，等待的<code>channel</code>输入，等等）。</li><li>A <strong>cancelation signal</strong>（取消信号）。一旦我们收到信号，我们必须停止正在进行的活动。例如，假设我们收到两个请求：一个用来插入一些数据，另一个用来取消第一个请求。这可以通过在第一个调用中使用<code>cancelable</code>上下文来实现，一旦我们获得第二个请求，这个上下文就会被取消。</li><li>A list of key/value （键/值列表）均基于<code>interface{}</code>类型。</li></ul><p>值得一提的是，<strong>Context 是可以组合的</strong>。例如，我们可以继承一个带有截止日期和键/值列表的<code>Context</code>。此外，多个<code>goroutines</code>可以共享相同的<code>Context</code>，取消一个<code>Context</code>可能会停止多个活动。</p><p>回到我们的主题，举一个我经历的例子。</p><p>一个基于<a href="https://github.com/urfave/cli" target="_blank" rel="external nofollow noopener noreferrer">urfave/cli</a> （<em>如果您不知道，这是一个很好的库，可以在 Go 中创建命令行应用程序</em>）创建的 Go 应用。一旦开始，程序就会继承父级的<code>Context</code>。这意味着当应用程序停止时，将使用此<code>Context</code>发送取消信号。</p><p>我经历的是，这个<code>Context</code>是在调用<code>gRPC</code>时直接传递的，这不是我想做的。相反，我想当应用程序停止时或无操作 100 毫秒后，发送取消请求。</p><p>为此，可以简单地创建一个组合的<code>Context</code>。如果<code>parent</code>是父级的<code>Context</code>的名称（<em>由 urfave/cli 创建</em>），那么组合操作如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(parent, <span class="number">100</span> * time.Millisecond)</span><br><span class="line">response, err := grpcClient.Send(ctx, request)</span><br></pre></td></tr></tbody></table></figure><p><code>Context</code>并不复杂，在我看来，可谓是 Go 的最佳特性之一。</p><h4 id="延伸阅读-3"><a href="#延伸阅读-3" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><ol><li><a href="http://p.agnihotry.com/post/understanding_the_context_package_in_golang/?source=post_page-----4b79d4f6cd65----------------------" target="_blank" rel="external nofollow noopener noreferrer">Understanding the context package in golang</a></li><li><a href="https://grpc.io/blog/deadlines/?source=post_page-----4b79d4f6cd65----------------------" target="_blank" rel="external nofollow noopener noreferrer">gRPC and Deadlines</a></li></ol><h3 id="被遗忘的-race-参数"><a href="#被遗忘的-race-参数" class="headerlink" title="被遗忘的-race 参数"></a>被遗忘的-race 参数</h3><p>我经常看到的一个错误是在没有<code>-race</code>参数的情况下测试 Go 应用程序。</p><p>正如<a href="https://blog.acolyer.org/2019/05/17/understanding-real-world-concurrency-bugs-in-go/" target="_blank" rel="external nofollow noopener noreferrer">本报告</a>所述，虽然 Go“旨在使并发编程更容易，更不容易出错”，但我们仍然遇到很多并发问题。</p><p>显然，Go 竞争检测器无法解决每一个并发问题。但是，它仍有很大价值，我们应该在测试应用程序时始终启用它。</p><h4 id="延伸阅读-4"><a href="#延伸阅读-4" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p><a href="https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb" target="_blank" rel="external nofollow noopener noreferrer">Does the Go race detector catch all data race bugs?</a></p><h3 id="更完美的封装"><a href="#更完美的封装" class="headerlink" title="更完美的封装"></a>更完美的封装</h3><p>另一个常见错误是将文件名传递给函数。</p><p>假设我们实现一个函数来计算文件中的空行数。最初的实现是这样的：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> {</span><br><span class="line">  file, err := os.Open(filename)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, errors.Wrapf(err, <span class="string">"unable to open %s"</span>, filename)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">  scanner := bufio.NewScanner(file)</span><br><span class="line">  count := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> scanner.Scan() {</span><br><span class="line">    <span class="keyword">if</span> scanner.Text() == <span class="string">""</span> {</span><br><span class="line">      count++</span><br><span class="line">    }</span><br><span class="line">  } </span><br><span class="line">  <span class="keyword">return</span> count, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>filename</code> 作为给定的参数，然后我们打开该文件，再实现读空白行的逻辑，嗯，没有问题。</p><p>假设我们希望在此函数之上实现单元测试，并使用普通文件，空文件，具有不同编码类型的文件等进行测试。代码很容易变得非常难以维护。</p><p>此外，如果我们想对于<code>HTTP Body</code>实现相同的逻辑，将不得不为此创建另一个函数。</p><p>Go 设计了两个很棒的接口：<code>io.Reader</code> 和 <code>io.Writer</code> (译者注：常见 IO 命令行，文件，网络等)</p><p>所以可以传递一个抽象数据源的<code>io.Reader</code>，而不是传递文件名。</p><p>仔细想一想统计的只是文件吗？一个 HTTP 正文？字节缓冲区？</p><p>答案并不重要，重要的是无论<code>Reader</code>读取的是什么类型的数据，我们都会使用相同的<code>Read</code>方法。</p><p>在我们的例子中，甚至可以缓冲输入以逐行读取它（使用<code>bufio.Reader</code>及其<code>ReadLine</code>方法）：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(reader *bufio.Reader)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> {</span><br><span class="line">  count := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> {</span><br><span class="line">    line, _, err := reader.ReadLine()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">      <span class="keyword">switch</span> err {</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.Wrapf(err, <span class="string">"unable to read"</span>)</span><br><span class="line">      <span class="keyword">case</span> io.EOF:</span><br><span class="line">        <span class="keyword">return</span> count, <span class="literal">nil</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) == <span class="number">0</span> {</span><br><span class="line">      count++</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>打开文件的逻辑现在交给调用<code>count</code>方：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">  <span class="keyword">return</span> errors.Wrapf(err, <span class="string">"unable to open %s"</span>, filename)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">count, err := count(bufio.NewReader(file))</span><br></pre></td></tr></tbody></table></figure><p>无论数据源如何，都可以调用<code>count</code>。并且，还将促进单元测试，因为可以从字符串创建一个<code>bufio.Reader</code>，这大大提高了效率。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count, err := count(bufio.NewReader(strings.NewReader(<span class="string">"input"</span>)))</span><br></pre></td></tr></tbody></table></figure><h3 id="Goruntines-与循环变量"><a href="#Goruntines-与循环变量" class="headerlink" title="Goruntines 与循环变量"></a>Goruntines 与循环变量</h3><p>我见过的最后一个常见错误是使用 Goroutines 和循环变量。</p><p>以下示例将会输出什么？</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ints := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> ints {</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, i)</span><br><span class="line">  }()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>乱序输出 <code>1 2 3</code> ？答错了。</p><p>在这个例子中，每个 Goroutine 共享相同的变量实例，因此最有可能输出<code>3 3 3</code>。</p><p>有两种解决方案可以解决这个问题。</p><p>第一种是将<code>i</code>变量的值传递给闭包（内部函数）：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ints := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> ints {</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, i)</span><br><span class="line">  }(i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二种是在<code>for</code>循环范围内创建另一个变量：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ints := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> ints {</span><br><span class="line">  i := i</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, i)</span><br><span class="line">  }()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>i := i</code>可能看起来有点奇怪，但它完全有效。</p><p>因为处于循环中意味着处于另一个作用域内，所以<code>i := i</code>相当于创建了另一个名为<code>i</code>的变量实例。</p><p>当然，为了便于阅读，最好使用不同的变量名称。</p><h4 id="延伸阅读-5"><a href="#延伸阅读-5" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p><a href="https://github.com/golang/go/wiki/CommonMistakes?source=post_page-----4b79d4f6cd65----------------------#using-goroutines-on-loop-iterator-variables" target="_blank" rel="external nofollow noopener noreferrer">Using goroutines on loop iterator variables</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>你还想提到其他常见的错误吗？请随意分享，继续讨论；)</p><p>转载本站文章请注明作者和出处 <a href="http://tomotoes.com">一个坏掉的番茄</a>，请勿用于任何商业用途。</p></div><div class="recommended_posts"><div class="recommended_wrap"><h2 class="recommended_title">相关文章</h2><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"> <a href="/blog/build-static-site-generator-nodejs/" rel="bookmark">手撸一个静态文档生成器[译]</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"> <a href="/blog/magic-bit-operation/" rel="bookmark">神奇的位运算</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"> <a href="/blog/7-code-smells-in-react-components/" rel="bookmark">React 的 7 种代码异味[译]</a></div></li></ul></div></div><blockquote class="post-copyright"><div class="content"> <span class="post-time">最后更新：<time datetime="2021-02-14T17:22:36.312Z">2021-02-15 01:22:36</time></span> 原文链接：<a href="/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/" target="_blank" rel="external">https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/</a></div><footer><div> <img itemprop="image" lass="copyimg" src="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/avatar.jpg" alt="Simon Ma"> <a itemprop="author" itemscope itemtype="http://schema.org/Person" href="/blog">Simon Ma</a></div></footer></blockquote><div class="page-reward"><nav class="inner-reward"> <a id="rewardBtn" href="javascript:;"><span>打&nbsp;赏</span> <span>装成好像很多人打赏的样子</span></a></nav></div><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close2 custom-close"></i></a><br><h3 class="reward-title"><i class="icon icon-quote-left custom-quote-left"></i> <span>感谢您的鼓励支持！</span><i class="icon icon-quote-right custom-quote-right"></i></h3><div class="reward-content"><div class="reward-code"> <img id="rewardCode" src="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/dog.png" data-wechat="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/wechat.png" data-alipay="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/alipay.png" alt="打赏二维码"></div> <label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" aria-label="reward"><div class="reward-toggle-ctrol"> <span class="reward-toggle-item wechatPay">&nbsp;&nbsp;微信&nbsp;&nbsp;</span> <span class="reward-toggle-item alipayPay">支付宝</span></div></label><i class="icon icon-caretup custom-caret-up"></i></div></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Go/" rel="tag">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E8%AF%91%E6%96%87/" rel="tag">译文</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="facebook share-sns" rel="external nofollow noopener noreferrer" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/" title="Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" rel="external nofollow noopener noreferrer" target="_blank" href="https://twitter.com/intent/tweet?text=《Go 开发中的十大常见陷阱[译]》 — 一个坏掉的番茄&url=https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/&via=https://tomotoes.com/blog" title=" Twitter"><i class="icon icon-twitter"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/blog/scrcpy-gui/" id="post-prev" class="post-nav-link"><h4 class="title"> 上一篇：[开源福利]Scrcpy-GUI</h4></a></div><div class="waves-block waves-effect next"><a href="/blog/resume/" id="post-next" class="post-nav-link"><h4 class="title" data-hover="下一篇：个人简历">下一篇：个人简历</h4></a></div></nav><section class="comments" id="comments"><div class="comment-tips">因不可抗拒因素，麻烦站在墙外交流~</div><div id="disqus_thread"></div></section></article></div></main><div class="bgheader"><div id="header-hero"></div></div><template id="cube-template"><div class="cube fade"><div class="shadow"></div><div class="sides"><div class="back"></div><div class="top"></div><div class="left"></div><div class="front"></div><div class="right"></div><div class="bottom"></div></div></div></template><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="fade-scale waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevronup"></span></a><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item waves-block waves-effect" onclick="location.href='{path}'"><div class="title ellipsis" title="{title}">{title}</div></li></template><div id="color-picker" class="page-modal"><a class="close" href="javascript:;"><i class="icon icon-close2"></i></a><br><h4><i class="icon icon-quote-left"></i> <span>自定义主题颜色</span><i class="icon icon-quote-right"></i></h4><div id="color-picker-container"></div></div><script src="https://tomotoes.com/registerSW.js?v=2705cb8a04462"></script><script src="https://cdn.jsdelivr.net/gh/Tomotoes/js/log.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/headroom.js@0.12.0/dist/headroom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5.2.3/dist/iro.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/js/main-e8e4c55efc.js"></script><script src="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/js/script-f65677cca0.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/js/module/post-72698b6b60.js"></script><script defer src="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/js/module/comment-bbb0691887.js"></script><script defer src="https://cdn.jsdelivr.net/gh/Tomotoes/js/translate-ff7607fcb8.js"></script></body></html>