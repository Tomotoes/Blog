<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,maximum-scale=2,viewport-fit=cover"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><meta name="author" content="Simon Ma"><link rel="icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/favicon.ico"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/favicon.ico"><link rel="apple-touch-icon" href="https://cdn.jsdelivr.net/gh/Tomotoes/images/PWA/apple-touch-icon.png"><title>30s 源码刨析系列之函数篇</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/font/comic.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-roboto@1.1.13/index.min.css"><link id="style" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/style-37d854d498.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/post-3566510171.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/module/relatedPosts-25786aa404.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/module/comment-bfd02bb730.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/module/reward-fc1e0c7470.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/firacode@5.2.0/distr/fira_code.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/css/highlight-271688128f.css"><meta name="theme-color"><meta name="apple-mobile-web-app-status-bar-style"><meta name="msapplication-navbutton-color"><script>
	window.selectedColor = ''
	window.themeColor = localStorage.getItem("theme-color") || "#7af"
	window.changeColor = function(themeColor){
		document.documentElement.style.setProperty('--theme-color', themeColor);
		document.querySelector("meta[name=theme-color]").setAttribute("content", themeColor);
		document.querySelector("meta[name=apple-mobile-web-app-status-bar-style]").setAttribute("content", themeColor);
		document.querySelector("meta[name=msapplication-navbutton-color]").setAttribute("content", themeColor);
		localStorage.setItem('theme-color', themeColor)
	}
	changeColor(themeColor)

	window.isPhone = /Android|iOS|iPhone|iPad|iPod|Windows Phone|KFAPWI/i.test(navigator.userAgent) || (window.innerWidth <= 1370)
	window.isHome = false
	window.isPost = true
	if(window.isPost){
		window.isReward = true
	}
</script><link rel="manifest" href="https://tomotoes.com/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="mobile-web-app-title" content="一个坏掉的番茄"><meta name="msapplication-starturl" content="https://tomotoes.com"><meta name="application-name" content="一个坏掉的番茄"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="一个坏掉的番茄"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="prefetch" href="https://cdn.jsdelivr.net/"><link rel="dns-prefetch" href="https://api.github.com/"><link rel="dns-prefetch" href="https://disqus.com"><link rel="dns-prefetch" href="https://tomotoes-com.disqus.com"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-109696496-3"></script><script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'UA-109696496-3');
</script><link rel="canonical" href="https://tomotoes.com/blog/30s-javascript-function/"><link rel="alternate" type="application/atom+xml" title="一个坏掉的番茄" href="/blog/atom.xml"><meta property="og:title" content="30s 源码刨析系列之函数篇 | 一个坏掉的番茄"><meta property="og:site_name" content="一个坏掉的番茄"><meta property="og:type" content="article"><meta property="og:url" content="https://tomotoes.com/blog/30s-javascript-function/"><meta property="og:locale" content="zh-CN"><meta name="description" content="30secondsofcode 源码深入解析之 JavaScript 函数篇, 里面覆盖了大量函数式案例,由浅入深逐个击破各个代码片段, 带你领略源码之美 - Simon Ma - 一个坏掉的番茄"><meta name="keywords" content="30secondsofcode,函数防抖,函数节流,柯里化,反柯里化,Promise,异步函数,链式调用,源码刨析,源码,JavaScript,函数式,一个坏掉的番茄,Blog,博客,Tomotoes,SimonMa,SimonAKing,Codenter,jinma,马寂寞"><meta property="article:published_time" content="2020-03-01T03:43:52.000Z"><meta property="article:modified_time" content="2021-02-14T17:22:36.301Z"><meta property="og:updated_time" content="2021-02-14T17:22:36.301Z"><meta property="article:author" content="Simon Ma"><meta property="article:tag" content="30secondsofcode,函数防抖,函数节流,柯里化,反柯里化,Promise,异步函数,链式调用,源码刨析,源码,JavaScript,函数式,一个坏掉的番茄,Blog,博客,Tomotoes,SimonMa,SimonAKing,Codenter,jinma,马寂寞"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="https:&#x2F;&#x2F;tomotoes.com&#x2F;blog&#x2F;30s-javascript-function&#x2F;"><meta name="twitter:creator" content="Simon Ma"><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "https://tomotoes.com/blog/30s-javascript-function/",
    "@type": "BlogPosting",
    "logo": "https://tomotoes.com/images/PWA/192.png",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://tomotoes.com/blog/30s-javascript-function/"
    },
    "headline": "30s 源码刨析系列之函数篇 | 一个坏掉的番茄",
    "image": {
        "@type": "ImageObject",
        "url": "https://tomotoes.com/images/PWA/192.png"
    },
    "datePublished": "2020-03-01T03:43:52.000Z",
    "dateModified": "2021-02-14T17:22:36.301Z",
    "author": {
        "@type": "Person",
        "name": "Simon Ma",
        "image": {
            "@type": "ImageObject",
            "url": "https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/avatar.jpg"
        },
        "description": "Input &amp; Think &amp; Output"
    },
    "publisher": {
        "@type": "Organization",
        "name": "一个坏掉的番茄",
        "logo": {
            "@type": "ImageObject",
            "url": "https://tomotoes.com/images/PWA/192.png"
        }
    },
    "keywords": "30secondsofcode,函数防抖,函数节流,柯里化,反柯里化,Promise,异步函数,链式调用,源码刨析,源码,JavaScript,函数式,一个坏掉的番茄,Blog,博客,Tomotoes,SimonMa,SimonAKing,Codenter,jinma,马寂寞",
    "description": "30secondsofcode 源码深入解析之 JavaScript 函数篇, 里面覆盖了大量函数式案例,由浅入深逐个击破各个代码片段, 带你领略源码之美 - Simon Ma - 一个坏掉的番茄"
}
</script><!--[if lt IE 9]><style> .alert { padding: 15px; margin-bottom: 20px; border: 1px solid transparent; border-radius: 4px } .alert-danger { background-color: #f2dede; border-color: #ebccd1; color: #a94442; border-bottom: 1px solid #ebccd1 } .alert-link { color: #843534; font-weight: bold } .topframe { margin: 0; padding-left: 15px; padding-right: 15px; text-align: center; border-radius: 0; position: fixed; left: 0; right: 0; top: 0; z-index: 1000 } </style><div class="alert alert-danger topframe"> 你的浏览器实在<strong>太太太太太太旧了</strong>，放学别走，升级完浏览器再说！ <a target="_blank" class="alert-link" href="//browsehappy.com">立即升级</a></div><script src="https://cdn.bootcss.com/html5shiv/r29/html5.min.js"></script><script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script><![endif]--></head><body itemscope itemtype="http://schema.org/WebPage"><aside id="menu" class="hide"><div class="inner flex-row-vertical"><div class="brand-wrap" itemprop="author" itemscope itemtype="http://schema.org/Person"><div class="brand fade"> <a class="avatar waves-effect waves-circle waves-light"><img src="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/avatar.jpg" title="avatar" alt="avatar" itemprop="image"></a><div class="introduce"><h5 class="nickname " id="name">Simon Ma</h5><div class="links-of-author fade"> <span class="links-of-author-item"><a href="https://github.com/Tomotoes" rel="external nofollow noopener noreferrer" target="_blank" title="Github"><i class="icon icon-lg icon-github"><span>Tomotoes</span></i></a></span> <span class="links-of-author-item"><a href="https://twitter.com/simon_aking" rel="external nofollow noopener noreferrer" target="_blank" title="Twitter"><i class="icon icon-lg icon-twitter"><span>SimonAKing</span></i></a></span> <span class="links-of-author-item"><a href="https://t.me/tomotoes" rel="external nofollow noopener noreferrer" target="_blank" title="TG频道"><i class="icon icon-lg icon-telegram"><span>TG频道</span></i></a></span></div><div class="statistics"><ul><li><a class="total-link" href="/blog/weibo/"><div class="count" id="weibo-count">∞</div><div class="type">微博</div></a></li><li><a class="total-link" href="/blog/archives/"><div class="count">37</div><div class="type">文章</div></a></li><li><a class="total-link" href="/gallery/"><div class="count" id="photo-count">∞</div><div class="type">相册</div></a></li></ul></div></div></div></div><div class="scroll-wrap flex-col"><ul class="nav fade"><li class="items waves-block waves-effect"><a href="/blog/"><i class="icon icon-lg icon-xiazai45"></i> <span style="font-size:1em">主 页</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="/blog/archives/"><i class="icon icon-lg icon-guidangxiangmu"></i> <span style="font-size:1em">归 档</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="/blog/tags/"><i class="icon icon-lg icon-biaoqian"></i> <span style="font-size:1em">标 签</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="/blog/weibo/"><i class="icon icon-lg icon-biaoqing"></i> <span style="font-size:1em">微 博</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//tomotoes.com/gallery/"><i class="icon icon-lg icon-xiangce"></i> <span style="font-size:1em">相 册</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//thinking.tomotoes.com/" target="_blank" rel="noopener"><i class="icon icon-lg icon--Idea"></i> <span style="font-size:1em">阅 读</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//tomotoes.com/about/"><i class="icon icon-lg icon-zhifeiji"></i> <span style="font-size:1em">关 于</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//tomotoes.com"><i class="icon icon-lg icon-icon--"></i> <span style="font-size:1em">导航</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><div class="sliding-bar"></div></ul><div class="nav-tool"><a class="nav-tool-item exchange" data-title="简繁互换" href="javascript:translatePage();"><i class="fade icon icon-lg icon-zhuanhuan custom-exchange"></i></a><a class="nav-tool-item picker" data-title="调色板" id="color-picker-icon"><i class="fade icon icon-lg icon-color-palette-outlin custom-picker"></i></a><a class="nav-tool-item light" data-title="关灯" href="javascript:switchNightMode();"><i class="fade icon icon-lg icon-lightbulbo custom-lightbulb"></i></a></div></div></div></aside><main id="main"><header class="top-header" id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-naviconround"></i></a><div class="flex-col header-title ellipsis">30s 源码刨析系列之函数篇</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevronleft"></i></a> <input type="text" id="key" aria-label="search" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" title="搜索" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div></div></header><header class="content-header post-header"></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap fade" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#正文"><span class="post-toc-number">2.</span> <span class="post-toc-text">正文</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#新手级"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">新手级</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#checkProp"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">checkProp</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#functionName"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">functionName</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#negate"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">negate</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#unary"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">unary</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#普通级"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">普通级</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ary"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">ary</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#attempt"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">attempt</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#bind"><span class="post-toc-number">2.2.3.</span> <span class="post-toc-text">bind</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#bindKey"><span class="post-toc-number">2.2.4.</span> <span class="post-toc-text">bindKey</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#call"><span class="post-toc-number">2.2.5.</span> <span class="post-toc-text">call</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#chainAsync"><span class="post-toc-number">2.2.6.</span> <span class="post-toc-text">chainAsync</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#collectInto"><span class="post-toc-number">2.2.7.</span> <span class="post-toc-text">collectInto</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#compose"><span class="post-toc-number">2.2.8.</span> <span class="post-toc-text">compose</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#composeRight"><span class="post-toc-number">2.2.9.</span> <span class="post-toc-text">composeRight</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#converge"><span class="post-toc-number">2.2.10.</span> <span class="post-toc-text">converge</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#curry"><span class="post-toc-number">2.2.11.</span> <span class="post-toc-text">curry</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#debounce"><span class="post-toc-number">2.2.12.</span> <span class="post-toc-text">debounce</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#defer"><span class="post-toc-number">2.2.13.</span> <span class="post-toc-text">defer</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#delay"><span class="post-toc-number">2.2.14.</span> <span class="post-toc-text">delay</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#flip"><span class="post-toc-number">2.2.15.</span> <span class="post-toc-text">flip</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#hz"><span class="post-toc-number">2.2.16.</span> <span class="post-toc-text">hz</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#once"><span class="post-toc-number">2.2.17.</span> <span class="post-toc-text">once</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#over"><span class="post-toc-number">2.2.18.</span> <span class="post-toc-text">over</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#overArgs"><span class="post-toc-number">2.2.19.</span> <span class="post-toc-text">overArgs</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#partial"><span class="post-toc-number">2.2.20.</span> <span class="post-toc-text">partial</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#partialRight"><span class="post-toc-number">2.2.21.</span> <span class="post-toc-text">partialRight</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pipeAsyncFunctions"><span class="post-toc-number">2.2.22.</span> <span class="post-toc-text">pipeAsyncFunctions</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#promisify"><span class="post-toc-number">2.2.23.</span> <span class="post-toc-text">promisify</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#rearg"><span class="post-toc-number">2.2.24.</span> <span class="post-toc-text">rearg</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#runPromisesInSeries"><span class="post-toc-number">2.2.25.</span> <span class="post-toc-text">runPromisesInSeries</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sleep"><span class="post-toc-number">2.2.26.</span> <span class="post-toc-text">sleep</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#spreadOver"><span class="post-toc-number">2.2.27.</span> <span class="post-toc-text">spreadOver</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#times"><span class="post-toc-number">2.2.28.</span> <span class="post-toc-text">times</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#uncurry"><span class="post-toc-number">2.2.29.</span> <span class="post-toc-text">uncurry</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#unfold"><span class="post-toc-number">2.2.30.</span> <span class="post-toc-text">unfold</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#when"><span class="post-toc-number">2.2.31.</span> <span class="post-toc-text">when</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#专家级"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">专家级</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#memoize"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">memoize</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#throttle"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">throttle</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结束语"><span class="post-toc-number">3.</span> <span class="post-toc-text">结束语</span></a></li></ol></nav></aside><article id="post-30s源码刨析系列之函数篇" class="post-article article-type-post fade" itemscope itemtype="http://schema.org/Article"><div class="post-card"><h1 class="post-card-title" itemprop="name headline">&nbsp;</h1><script>
			window.addEventListener('DOMContentLoaded', function (){ var postTitle = document.querySelector('.post-card-title'); var typingbefore = '30s 源码刨析系列之函数篇'; var _i = 0; function typetitle() { if (_i <= typingbefore.length) { postTitle.innerHTML = `${typingbefore.slice(0, _i++)}|`; setTimeout(typetitle, 120); } else { postTitle.innerHTML = typingbefore; } } typetitle(); })
		</script><div class="post-meta"><div class="post-category-phone"><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/%E6%BA%90%E7%A0%81/">源码</a></li></ul></div> <time itemprop="dateCreated datePublished" class="post-time" title="2020-03-01 11:43:52" datetime="2020-03-01T03:43:52.000Z">2020-03-01</time></div><div class="post-category" itemprop="about" itemscope itemtype="http://schema.org/Thing"><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/%E6%BA%90%E7%A0%81/">源码</a></li></ul></div><div class="post-count-custom"><i class="icon icon-lg icon-commenting-o"></i> 阅读本文可能花费您&nbsp;<span class="post-count">26</span>&nbsp;分钟</div><link itemprop="mainEntityOfPage" href="https://tomotoes.com/blog/30s-javascript-function/" style="display:none"><div class="post-content" id="post-content" itemprop="articleBody"><p>由浅入深、逐个击破 <a href="https://www.30secondsofcode.org/js/t/function/p/1/" target="_blank" rel="external nofollow noopener noreferrer">30SecondsOfCode</a> 中函数系列所有源码片段，带你领略源码之美。<a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列是对名库 <a href="https://www.30secondsofcode.org/" target="_blank" rel="external nofollow noopener noreferrer">30SecondsOfCode</a> 的深入刨析。</p><p>本篇是其中的函数篇，可以在极短的时间内培养你的函数式思维。</p><p>内容根据源码的难易等级进行排版，目录如下：</p><ol><li>新手级</li><li>普通级</li><li>专家级</li></ol><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="新手级"><a href="#新手级" class="headerlink" title="新手级"></a>新手级</h3><h4 id="checkProp"><a href="#checkProp" class="headerlink" title="checkProp"></a>checkProp</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkProp = <span class="function">(<span class="params">predicate, prop</span>) =&gt;</span> <span class="function"><span class="params">obj</span> =&gt;</span> !!predicate(obj[prop]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lengthIs4 = checkProp(<span class="function"><span class="params">l</span> =&gt;</span> l === <span class="number">4</span>, <span class="string">'length'</span>);</span><br><span class="line">lengthIs4([]); <span class="comment">// false</span></span><br><span class="line">lengthIs4([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// true</span></span><br><span class="line">lengthIs4(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// false (Set uses Size, not length)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> session = { <span class="attr">user</span>: {} };</span><br><span class="line"><span class="keyword">const</span> validUserSession = checkProp(<span class="function"><span class="params">u</span> =&gt;</span> u.active &amp;&amp; !u.disabled, <span class="string">'user'</span>);</span><br><span class="line"></span><br><span class="line">validUserSession(session); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">session.user.active = <span class="literal">true</span>;</span><br><span class="line">validUserSession(session); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> noLength = checkProp(<span class="function"><span class="params">l</span> =&gt;</span> l === <span class="literal">undefined</span>, <span class="string">'length'</span>);</span><br><span class="line">noLength([]); <span class="comment">// false</span></span><br><span class="line">noLength({}); <span class="comment">// true</span></span><br><span class="line">noLength(<span class="keyword">new</span> <span class="built_in">Set</span>()); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>作用：检查参数是否存在给定的属性。</p><p>解析：给定一个检查函数，和所需检查的属性名，返回一个函数。可通过调用 返回的函数，去判定 传入的对象参数是否符合检查函数。</p><h4 id="functionName"><a href="#functionName" class="headerlink" title="functionName"></a>functionName</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> functionName = <span class="function"><span class="params">fn</span> =&gt;</span> (<span class="built_in">console</span>.debug(fn.name), fn);</span><br><span class="line"></span><br><span class="line">functionName(<span class="built_in">Math</span>.max); <span class="comment">// max (logged in debug channel of console)</span></span><br></pre></td></tr></tbody></table></figure><p>作用：打印函数名。</p><p>解析：使用<code>console.debug</code>API 和函数的<code>name</code>属性，把 函数类型参数的名字 打印到控制台的 debug channel 中。</p><h4 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> negate = <span class="function"><span class="params">func</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> !func(...args);</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>].filter(negate(<span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>)); <span class="comment">// [ 1, 3, 5 ]</span></span><br></pre></td></tr></tbody></table></figure><p>作用：反转 谓词函数（返回类型为布尔的函数）的返回结果。</p><p>解析：假设有一谓词函数为<code>func = args =&gt; bool</code>，我们想要反转其结果，便可对它的调用方式进行进一步的抽象，把反转结果的逻辑放置抽象中。</p><p>在本函数中，只需要一个 逻辑非运算符<code>!func(...args)</code>。</p><p>而扩展运算符<code>...</code>是对参数的抽象，代表的是传入的所有参数，我们要将所有参数一个不差地传递，不可破环 谓词函数的“纯洁性”。</p><h4 id="unary"><a href="#unary" class="headerlink" title="unary"></a>unary</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unary = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">val</span> =&gt;</span> fn(val);</span><br><span class="line"></span><br><span class="line">[<span class="string">'6'</span>, <span class="string">'8'</span>, <span class="string">'10'</span>].map(unary(<span class="built_in">parseInt</span>)); <span class="comment">// [6, 8, 10]</span></span><br></pre></td></tr></tbody></table></figure><p>作用：参数函数调用时 只接受 参数函数的第一个参数，忽略其他参数。</p><p>解析：包装一个函数，并不做任何处理：<code>wrap = fn =&gt; (...args) =&gt; fn(...args)</code></p><p>很显然，如果想对传入的参数进行处理，只需对<code>args</code>动刀，而本例直接使用了单独的一个变量，忽略了其他参数。</p><h3 id="普通级"><a href="#普通级" class="headerlink" title="普通级"></a>普通级</h3><h4 id="ary"><a href="#ary" class="headerlink" title="ary"></a>ary</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ary = <span class="function">(<span class="params">fn, n</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fn(...args.slice(<span class="number">0</span>, n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstTwoMax = ary(<span class="built_in">Math</span>.max, <span class="number">2</span>);</span><br><span class="line">[[<span class="number">2</span>, <span class="number">6</span>, <span class="string">'a'</span>], [<span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>], [<span class="number">10</span>]].map(<span class="function"><span class="params">x</span> =&gt;</span> firstTwoMax(...x)); <span class="comment">// [6, 6, 1</span></span><br></pre></td></tr></tbody></table></figure><p>作用：参数函数调用时 只接受 参数函数的前 n 个参数，忽略其他参数。</p><p>解析：和上列逻辑如出一辙，只不过处理参数的逻辑换成了<code>...args.slice(0, n)</code>，只要前 n 个。</p><h4 id="attempt"><a href="#attempt" class="headerlink" title="attempt"></a>attempt</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> attempt = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">return</span> fn(...args);</span><br><span class="line">  } <span class="keyword">catch</span> (e) {</span><br><span class="line">    <span class="keyword">return</span> e <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? e : <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elements = attempt(<span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.querySelectorAll(selector);</span><br><span class="line">}, <span class="string">'&gt;_&gt;'</span>);</span><br><span class="line"><span class="keyword">if</span> (elements <span class="keyword">instanceof</span> <span class="built_in">Error</span>) elements = []; <span class="comment">// elements = []</span></span><br></pre></td></tr></tbody></table></figure><p>作用：对 参数函数 进行异常捕获，如果有异常则抛出。</p><p>解析：对 参数函数 进行进一步封装，本例封装的逻辑是<code>try catch</code>，即捕获参数函数的异常。</p><p>很久之前，我看到过一个关于<code>java8</code>的 attempt 片段，里面还增加了重试逻辑。</p><p>js 实现代码如下:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> attempt = <span class="function">(<span class="params">fn, ...args, count, bound</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">return</span> fn(...args);</span><br><span class="line">  } <span class="keyword">catch</span> (e) {</span><br><span class="line">    <span class="keyword">if</span>(count == bound){</span><br><span class="line">      <span class="keyword">return</span> e <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? e : <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> attempt(fn, ...args, count + <span class="number">1</span>, bound)</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bind = <span class="function">(<span class="params">fn, context, ...boundArgs</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fn.apply(context, [...boundArgs, ...args]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">greeting, punctuation</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> greeting + <span class="string">' '</span> + <span class="keyword">this</span>.user + punctuation;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> freddy = { <span class="attr">user</span>: <span class="string">'fred'</span> };</span><br><span class="line"><span class="keyword">const</span> freddyBound = bind(greet, freddy);</span><br><span class="line"><span class="built_in">console</span>.log(freddyBound(<span class="string">'hi'</span>, <span class="string">'!'</span>)); <span class="comment">// 'hi fred!'</span></span><br></pre></td></tr></tbody></table></figure><p>作用：原生 API-<code>bind</code>的另一种实现。</p><p><code>fn.bind(context,...args)</code> =&gt; <code>bind(fn,context,...args)</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external nofollow noopener noreferrer">MDN 关于 bind 的解释</a>：</p><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p></blockquote><p>解析：首先，使用了<code>apply</code>将给定的 上下文参数 应用于 参数函数。</p><p>其次，利用 apply 只接受数组作为参数的规定，将最初传入的参数，和后续传入的参数按顺序合并在一个数组中传递进去。</p><h4 id="bindKey"><a href="#bindKey" class="headerlink" title="bindKey"></a>bindKey</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bindKey = <span class="function">(<span class="params">context, fn, ...boundArgs</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">  context[fn].apply(context, [...boundArgs, ...args]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> freddy = {</span><br><span class="line">  user: <span class="string">'fred'</span>,</span><br><span class="line">  greet: <span class="function"><span class="keyword">function</span>(<span class="params">greeting, punctuation</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> greeting + <span class="string">' '</span> + <span class="keyword">this</span>.user + punctuation;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> freddyBound = bindKey(freddy, <span class="string">'greet'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(freddyBound(<span class="string">'hi'</span>, <span class="string">'!'</span>)); <span class="comment">// 'hi fred!'</span></span><br></pre></td></tr></tbody></table></figure><p>作用：把上列中的<code>fn</code>换成了<code>context[fn]</code>。</p><p>解析：我们原来的 参数函数 变成了一个 上下文参数的一个属性，而将这个属性依附于上下文对象就成了一个函数<code>context[fn]</code>。</p><p>可以说，这个一个调用方式特殊的<code>bind</code>。</p><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> call = <span class="function">(<span class="params">key, ...args</span>) =&gt;</span> <span class="function"><span class="params">context</span> =&gt;</span> context[key](...args);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">  .then(call(<span class="string">'map'</span>, x =&gt; <span class="number">2</span> * x))</span><br><span class="line">  .then(<span class="built_in">console</span>.log); <span class="comment">// [ 2, 4, 6 ]</span></span><br><span class="line"><span class="keyword">const</span> map = call.bind(<span class="literal">null</span>, <span class="string">'map'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">  .then(map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">2</span> * x))</span><br><span class="line">  .then(<span class="built_in">console</span>.log); <span class="comment">// [ 2, 4, 6 ]</span></span><br></pre></td></tr></tbody></table></figure><p>作用：动态改变函数执行的上下文。</p><p>解析：给定一个属性参数，再给定一组调用参数，返回一个接受上下文对象的函数，并最终组合调用。</p><p>其实这里面暗含了一个约束，很显然，<code>context[key]</code>必须是一个函数。</p><p>这个片段本质是对上下文的抽象。举个例子：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filterMen = call(<span class="string">'filter'</span>, person =&gt; person.sex === <span class="string">'man'</span>)</span><br><span class="line"></span><br><span class="line">filterMen([{<span class="attr">sex</span>:<span class="string">'woman'</span>,...},{<span class="attr">sex</span>:<span class="string">'man'</span>,...},...])</span><br><span class="line"><span class="comment">// 如果有其他 上下文对象，本例中也就是数组 需要相同的 逻辑过滤呢？</span></span><br></pre></td></tr></tbody></table></figure><h4 id="chainAsync"><a href="#chainAsync" class="headerlink" title="chainAsync"></a>chainAsync</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chainAsync = <span class="function"><span class="params">fns</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> curr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> last = fns[fns.length - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">const</span> fn = fns[curr++];</span><br><span class="line">    fn === last ? fn() : fn(next);</span><br><span class="line">  };</span><br><span class="line">  next();</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">chainAsync([</span><br><span class="line">  next =&gt; {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'0 seconds'</span>);</span><br><span class="line">    setTimeout(next, <span class="number">1000</span>);</span><br><span class="line">  },</span><br><span class="line">  next =&gt; {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1 second'</span>);</span><br><span class="line">    setTimeout(next, <span class="number">1000</span>);</span><br><span class="line">  },</span><br><span class="line">  () =&gt; {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2 second'</span>);</span><br><span class="line">  }</span><br><span class="line">]);</span><br></pre></td></tr></tbody></table></figure><p>作用：将 函数数组转换为有决策权的链式函数调用。</p><p>我为什么称之有决策权的链式函数调用呢？</p><p>因为每个函数都会接受一个 next 方法参数，它代表的就是调用链中的下一个函数，所以什么时候调用下一个函数，要不要调用，决策权在你。</p><p>解析：其实这个片段很简单。</p><p>首先，<code>fns</code> 类型一个函数数组，其中除了最后一个函数都有隐含的约束，可以选择接受 next 参数。</p><p>而 next 参数的含义就是调用链中的下一个函数，说白了 就是数组中的下一个成员。</p><p>而最后一个函数是无参函数。</p><p>片段中复杂点在于：利用闭包存储了两个关键变量。</p><p>第一个是 调用链中的函数游标:<code>curr</code>；第二个是结束标志，最后一个函数:<code>last</code>。</p><p>每次链式向下调用前，都会进行一些逻辑处理：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> next = <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> fn = fns[curr++];</span><br><span class="line">  fn === last ? fn() : fn(next);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>先取出当前游标所在函数，再把游标指向下一个函数。</p><p>然后，判断是否是最后一个函数，是则直接调用，结束；反之，传入 next 调用。</p><p>如果，你是一个后端开发者，可以把其理解为中间件的工作模式。</p><h4 id="collectInto"><a href="#collectInto" class="headerlink" title="collectInto"></a>collectInto</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> collectInto = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fn(args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pall = collectInto(<span class="built_in">Promise</span>.all.bind(<span class="built_in">Promise</span>));</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">2000</span>, <span class="number">3</span>));</span><br><span class="line">Pall(p1, p2, p3).then(<span class="built_in">console</span>.log); <span class="comment">// [1, 2, 3] (after about 2 seconds)</span></span><br></pre></td></tr></tbody></table></figure><p>作用：将接受数组的函数更改为接受可变参数。</p><p>分析：利用了扩展运算符的性质，<code>...args</code>代表的是所有参数组成的数组，然后将这数组传递进去调用。</p><p>可别小看了这一片段，调用方式的改变会决定很多上层逻辑。</p><p>平常我们大概率都会，建立一个数组，收集所需的异步函数。</p><p>在本例中，很明显的看到 从参数为数组类型的约束 中解放了出来。</p><h4 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> f(g(...args)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> substract3 = <span class="function"><span class="params">x</span> =&gt;</span> x - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> add5 = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x * y;</span><br><span class="line"><span class="keyword">const</span> multiplyAndAdd5AndSubstract3 = compose(</span><br><span class="line">  substract3,</span><br><span class="line">  add5,</span><br><span class="line">  multiply</span><br><span class="line">);</span><br><span class="line">multiplyAndAdd5AndSubstract3(<span class="number">5</span>, <span class="number">2</span>); <span class="comment">// 12</span></span><br></pre></td></tr></tbody></table></figure><p>作用：将传入的多个[异步]函数以组合的方式 调用。</p><p>先将参数传入最后一个[异步]函数，然后将得到的结果，传入倒数第二个[异步]函数，以此类推。</p><p><code>compose</code>可以说是函数式编程的经典片段。</p><p>它的具体意义可以说是逻辑分层。像洋葱一样，一层一层地处理数据。</p><p>解析：fns 代表的是 传入的多个函数 组成的数组。</p><p>利用<code>reduce</code>方法实现函数的“洋葱”包裹。</p><p>因为这种逻辑语义表示效果不好，就直接上上面例子的代码流程了。</p><figure class="highlight lasso"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">reduce 第一次循环:</span><br><span class="line">f: substract3; </span><br><span class="line">g: add5; </span><br><span class="line">返回结果：(<span class="params">...</span>args) =&gt; substract3(add5(<span class="params">...</span>args));</span><br><span class="line"></span><br><span class="line">reduce 第二次循环：</span><br><span class="line">f: (<span class="params">...</span>args) =&gt; substract3(add5(<span class="params">...</span>args)); </span><br><span class="line">g: multiply; </span><br><span class="line">返回结果：</span><br><span class="line">(<span class="params">...</span>args1) =&gt; ((<span class="params">...</span>args2) =&gt; substract3(add5(<span class="params">...</span>args2)))(multiply(<span class="params">...</span>args1))</span><br><span class="line">优化后:</span><br><span class="line">(<span class="params">...</span>args) =&gt; substract3(add5(multiply(<span class="params">...</span>args)));</span><br><span class="line">循环下去，以此类推<span class="params">...</span></span><br><span class="line"></span><br><span class="line">最后的返回的形式：</span><br><span class="line">(<span class="params">...</span>args) =&gt; 第一个函数(第二个函数(第三个函数(<span class="params">...</span>最后一个函数(<span class="params">...</span>args))))</span><br></pre></td></tr></tbody></table></figure><p>PS: 说实话，我并不喜欢 compose，在上例中就可以很明显的看到缺点。</p><p>把很多函数组合起来，第一是缺少语义化，与之对应的例子就是 Promise 的 then 调用链，语义鲜明；</p><p>第二是无法添加函数与函数之间的抽象逻辑，只能一次写好。</p><p>第三是各个函数之间存在隐含的参数约束，很可怕的。</p><h4 id="composeRight"><a href="#composeRight" class="headerlink" title="composeRight"></a>composeRight</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> composeRight = <span class="function">(<span class="params">...fns</span>) =&gt;</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> g(f(...args)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line"><span class="keyword">const</span> substract3 = <span class="function"><span class="params">x</span> =&gt;</span> x - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> addAndSquare = composeRight(add, square,substract3);</span><br><span class="line">addAndSquareAndSubstract3(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 6</span></span><br></pre></td></tr></tbody></table></figure><p>作用：将传入的多个[异步]函数以组合的方式 调用。</p><p>先将参数传入第一个[异步]函数，然后将得到的结果，传入第二个[异步]函数，以此类推。</p><h4 id="converge"><a href="#converge" class="headerlink" title="converge"></a>converge</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> converge = <span class="function">(<span class="params">converger, fns</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> converger(...fns.map(<span class="function"><span class="params">fn</span> =&gt;</span> fn.apply(<span class="literal">null</span>, args)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> average = converge(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a / b, [</span><br><span class="line">  arr =&gt; arr.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a + v, <span class="number">0</span>),</span><br><span class="line">  arr =&gt; arr.length</span><br><span class="line">]);</span><br><span class="line">average([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]); <span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure><p>作用：将 函数数组的返回结果 传递到<code>converger</code>函数，进一步处理，可用作分析统计。</p><p>解析: 使用<code>map</code> 和<code>apply</code>将参数数据传递给每个处理函数，并将处理后的结果交给<code>converger</code>函数。</p><h4 id="curry"><a href="#curry" class="headerlink" title="curry"></a>curry</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn, arity = fn.length, ...args</span>) =&gt;</span></span><br><span class="line">  arity &lt;= args.length ? fn(...args) : curry.bind(<span class="literal">null</span>, fn, arity, ...args);</span><br><span class="line"></span><br><span class="line">curry(<span class="built_in">Math</span>.pow)(<span class="number">2</span>)(<span class="number">10</span>); <span class="comment">// 1024</span></span><br><span class="line">curry(<span class="built_in">Math</span>.min, <span class="number">3</span>)(<span class="number">10</span>)(<span class="number">50</span>)(<span class="number">2</span>); <span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure><p>作用：函数柯里化。</p><p>柯里化不管在是函数式思维的理解，还是现实面试中，都非常的重要。</p><p><a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="external nofollow noopener noreferrer">维基百科上 柯里化的解释</a>：</p><blockquote><p>把接受多个<a href="https://zh.wikipedia.org/wiki/參數_(程式設計" target="_blank" rel="external nofollow noopener noreferrer">参数</a>)的<a href="https://zh.wikipedia.org/wiki/函数" target="_blank" rel="external nofollow noopener noreferrer">函数</a>变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数</p></blockquote><p>解析：这个<code>bind</code>用得真是神了，借助它积累每次传进来的参数，等到参数足够时，再调用。</p><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, ms = <span class="number">0</span></span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> timeoutId;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>{</span><br><span class="line">    clearTimeout(timeoutId);</span><br><span class="line">    timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> fn.apply(<span class="keyword">this</span>, args), ms);</span><br><span class="line">  };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">'resize'</span>,</span><br><span class="line">  debounce(<span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.innerWidth);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.innerHeight);</span><br><span class="line">  }, <span class="number">250</span>)</span><br><span class="line">); <span class="comment">// Will log the window dimensions at most every 250ms</span></span><br></pre></td></tr></tbody></table></figure><p>作用：函数防抖。</p><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5" target="_blank" rel="external nofollow noopener noreferrer">什么是防抖和节流？有什么区别？如何实现？</a> 一文中关于防抖解释：</p><blockquote><p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。</p></blockquote><p>同样，防抖也是面试必考的点。</p><p>解析: 传入需防抖的函数，和防抖的时间间隔，返回一个已防抖化的函数。</p><p>主要借助<code>setTimeout</code>和<code>function + apply</code>保存上下文完成。</p><p>每次调用函数前，都执行一遍<code>clearTimeout</code>，保证重新计算调用时间。</p><p>无论是调用多么频繁的函数都会在指定时间的间隔后只运行一次。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defer = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> setTimeout(fn, <span class="number">1</span>, ...args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example A:</span></span><br><span class="line">defer(<span class="built_in">console</span>.log, <span class="string">'a'</span>), <span class="built_in">console</span>.log(<span class="string">'b'</span>); <span class="comment">// logs 'b' then 'a'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Example B:</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#someElement'</span>).innerHTML = <span class="string">'Hello'</span>;</span><br><span class="line">longRunningFunction(); <span class="comment">// Browser will not update the HTML until this has finished</span></span><br><span class="line">defer(longRunningFunction); <span class="comment">// Browser will update the HTML then run the function</span></span><br></pre></td></tr></tbody></table></figure><p>作用：推迟调用函数，直到清除当前调用堆栈。</p><p>可适用于推迟 cpu 密集型计算，以免阻塞渲染引擎工作。</p><p>分析：使用<code>setTimeout</code>（超时时间为 1ms）将 函数参数 添加到浏览器事件队列末尾。</p><p>因为 JavaScript 是单线程执行，先是主线程执行完毕，然后在读取事件队列中的代码执行。</p><p>如果主线程有运行时间太长的函数，会阻塞页面渲染，所以将其放置到事件队列。</p><h4 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> delay = <span class="function">(<span class="params">fn, wait, ...args</span>) =&gt;</span> setTimeout(fn, wait, ...args);</span><br><span class="line"></span><br><span class="line">delay(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  },</span><br><span class="line">  <span class="number">1000</span>,</span><br><span class="line">  <span class="string">'later'</span></span><br><span class="line">); <span class="comment">// Logs 'later' after one second.</span></span><br></pre></td></tr></tbody></table></figure><p>作用：延迟函数执行。</p><p>是的，它和<code>defer</code>非常像，但使用场景却是不一样。</p><p>defer 的目的是将占据主线程时间长的函数推迟到事件队列。</p><p>而 delay 只是字面意思，延迟执行。</p><p>解析：对 <code>setTimeout</code> 进行语义化封装。</p><h4 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flip = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function">(<span class="params">first, ...rest</span>) =&gt;</span> fn(...rest, first);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = { <span class="attr">name</span>: <span class="string">'John Smith'</span> };</span><br><span class="line"><span class="keyword">let</span> b = {};</span><br><span class="line"><span class="keyword">const</span> mergeFrom = flip(<span class="built_in">Object</span>.assign);</span><br><span class="line"><span class="keyword">let</span> mergePerson = mergeFrom.bind(<span class="literal">null</span>, a);</span><br><span class="line">mergePerson(b); <span class="comment">// == b</span></span><br><span class="line">b = {};</span><br><span class="line"><span class="built_in">Object</span>.assign(b, a); <span class="comment">// == b</span></span><br></pre></td></tr></tbody></table></figure><p>作用：对 参数函数 的输入数据进行进一步处理，将数据的第一个参数与其余参数位置对调。</p><p>解析：主要利用 扩展运算符的性质，对参数的位置进行调整。</p><p>如果你不了解这一语言特性，可参考阮一峰老师的<a href="https://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="external nofollow noopener noreferrer">ES6 入门</a>。</p><h4 id="hz"><a href="#hz" class="headerlink" title="hz"></a>hz</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hz = <span class="function">(<span class="params">fn, iterations = <span class="number">100</span></span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> before = performance.now();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iterations; i++) fn();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1000</span> * iterations) / (performance.now() - before);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10,000 element array</span></span><br><span class="line"><span class="keyword">const</span> numbers = <span class="built_in">Array</span>(<span class="number">10000</span>)</span><br><span class="line">  .fill()</span><br><span class="line">  .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test functions with the same goal: sum up the elements in the array</span></span><br><span class="line"><span class="keyword">const</span> sumReduce = <span class="function"><span class="params">()</span> =&gt;</span> numbers.reduce(<span class="function">(<span class="params">acc, n</span>) =&gt;</span> acc + n, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> sumForLoop = <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) sum += numbers[i];</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// `sumForLoop` is nearly 10 times faster</span></span><br><span class="line"><span class="built_in">Math</span>.round(hz(sumReduce)); <span class="comment">// 572</span></span><br><span class="line"><span class="built_in">Math</span>.round(hz(sumForLoop)); <span class="comment">// 4784</span></span><br></pre></td></tr></tbody></table></figure><p>作用：返回函数每秒执行一次的次数。</p><p>hz 是赫兹的单位（频率的单位）定义为每秒一个周期。</p><p>解析：通过两次使用<code>performance.now</code>获取<code>iterations</code>次迭代前后的毫秒差。</p><p>然后将毫秒转换为秒并除以经过的时间，可以得到每秒的函数执行次数。</p><p>PS: 此处，并没有太好的个人理解，翻译自<a href="https://www.30secondsofcode.org/js/s/hz/" target="_blank" rel="external nofollow noopener noreferrer">官方</a>。</p><h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> once = <span class="function"><span class="params">fn</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startApp = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, event); <span class="comment">// document.body, MouseEvent</span></span><br><span class="line">};</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, once(startApp)); <span class="comment">// only runs `startApp` once upon click</span></span><br></pre></td></tr></tbody></table></figure><p>作用：确保一个函数只被调用一次。</p><p>分析：因为 JavaScript 是单线程执行环境，不需要考虑并发环境，直接一个内部变量存到闭包中，每次调用前判断，并在第一次调用时，修改其值，让后续调用全部失效。</p><p>给你看一下 Go 的 once，官方是通过<code>atomic</code>库实现的：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sync</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> {</span><br><span class="line">    m    Mutex</span><br><span class="line">    done <span class="keyword">uint32</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> {</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">1</span> {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="keyword">if</span> o.done == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="over"><a href="#over" class="headerlink" title="over"></a>over</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> over = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fns.map(<span class="function"><span class="params">fn</span> =&gt;</span> fn.apply(<span class="literal">null</span>, args));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> minMax = over(<span class="built_in">Math</span>.min, <span class="built_in">Math</span>.max);</span><br><span class="line">minMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// [1,5]</span></span><br></pre></td></tr></tbody></table></figure><p>作用：利用函数数组，对接下来的输入数据进行处理，得到每个函数处理后的结果数组。</p><p>解析：使用<code>map</code>和<code>apply</code>将输入的数据传递到每个函数中进行处理。</p><h4 id="overArgs"><a href="#overArgs" class="headerlink" title="overArgs"></a>overArgs</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> overArgs = <span class="function">(<span class="params">fn, transforms</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fn(...args.map(<span class="function">(<span class="params">val, i</span>) =&gt;</span> transforms[i](val)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> fn = overArgs(<span class="function">(<span class="params">x, y</span>) =&gt;</span> [x, y], [square, double]);</span><br><span class="line">fn(<span class="number">9</span>, <span class="number">3</span>); <span class="comment">// [81, 6]</span></span><br></pre></td></tr></tbody></table></figure><p>作用：利用 transforms 函数数组，分别处理相应位置的输入数据，并把结果传递进给定函数。</p><p>解析：transforms 函数数组 和参数必须位置对应，这个约束有点强啊。</p><h4 id="partial"><a href="#partial" class="headerlink" title="partial"></a>partial</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...partials</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fn(...partials, ...args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greet = <span class="function">(<span class="params">greeting, name</span>) =&gt;</span> greeting + <span class="string">' '</span> + name + <span class="string">'!'</span>;</span><br><span class="line"><span class="keyword">const</span> greetHello = partial(greet, <span class="string">'Hello'</span>);</span><br><span class="line">greetHello(<span class="string">'John'</span>); <span class="comment">// 'Hello John!'</span></span><br></pre></td></tr></tbody></table></figure><p>作用：将调用函数的数据分为两次输入，并按正序调用。</p><p>解析：两次使用扩展运算符（…），保存不同时期的数据，最后调用。</p><h4 id="partialRight"><a href="#partialRight" class="headerlink" title="partialRight"></a>partialRight</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...partials</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fn(...args, ...partials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greet = <span class="function">(<span class="params">greeting, name</span>) =&gt;</span> greeting + <span class="string">' '</span> + name + <span class="string">'!'</span>;</span><br><span class="line"><span class="keyword">const</span> greetJohn = partialRight(greet, <span class="string">'John'</span>);</span><br><span class="line">greetJohn(<span class="string">'Hello'</span>); <span class="comment">// 'Hello John!'</span></span><br></pre></td></tr></tbody></table></figure><p>作用：将调用函数的数据分为两次输入，并按反序调用。</p><p>解析：两次使用扩展运算符（…），保存不同时期的数据，最后调用。</p><h4 id="pipeAsyncFunctions"><a href="#pipeAsyncFunctions" class="headerlink" title="pipeAsyncFunctions"></a>pipeAsyncFunctions</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipeAsyncFunctions = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function"><span class="params">arg</span> =&gt;</span> fns.reduce(<span class="function">(<span class="params">p, f</span>) =&gt;</span> p.then(f), <span class="built_in">Promise</span>.resolve(arg));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = pipeAsyncFunctions(</span><br><span class="line">  x =&gt; x + <span class="number">1</span>,</span><br><span class="line">  x =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(x + <span class="number">2</span>), <span class="number">1000</span>)),</span><br><span class="line">  x =&gt; x + <span class="number">3</span>,</span><br><span class="line">  <span class="keyword">async</span> x =&gt; (<span class="keyword">await</span> x) + <span class="number">4</span></span><br><span class="line">);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> sum(<span class="number">5</span>)); <span class="comment">// 15 (after one second)</span></span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure><p>作用：将传入的多个[异步]函数按照正序 依次调用。</p><p>解析：结合<code>reduce</code>和<code>Promise.then</code>，将数据按照正序传递到每个[异步]函数,进行处理，处理的结果又传给下一个[异步]函数，以此类推。</p><h4 id="promisify"><a href="#promisify" class="headerlink" title="promisify"></a>promisify</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="function"><span class="params">func</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    func(...args, (err, result) =&gt; (err ? reject(err) : resolve(result)))</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> delay = promisify(<span class="function">(<span class="params">d, cb</span>) =&gt;</span> setTimeout(cb, d));</span><br><span class="line">delay(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Hi!'</span>)); <span class="comment">// // Promise resolves after 2s</span></span><br></pre></td></tr></tbody></table></figure><p>作用：将回调函数改为<code>Promise</code>方式处理结果。</p><p>在 Node8+ ，你可以使用<em><code>util.promisify</code></em></p><p>解析：首先接受给定的回调函数，然后直接在 Promise 中调用该函数。</p><p>因为回调函数的结果按照规范永远是最后一个参数，我们只需要在函数调用时，把最后一个参数换成 Promise 的方式，即：如果回调函数出现错误则 reject，反之 resolve。</p><p>注意：被 promisify 的函数必须接受回调参数且后续会调用。</p><h4 id="rearg"><a href="#rearg" class="headerlink" title="rearg"></a>rearg</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rearg = <span class="function">(<span class="params">fn, indexes</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fn(...indexes.map(<span class="function"><span class="params">i</span> =&gt;</span> args[i]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rearged = rearg(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> [a, b, c];</span><br><span class="line">  },</span><br><span class="line">  [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">);</span><br><span class="line">rearged(<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></tbody></table></figure><p>作用：根据指定的索引重新排列传入的参数。</p><p>解析：利用<code>map</code>结合扩展运算符，重新排列传入的参数，并将转换后的参数传递给 fn。</p><h4 id="runPromisesInSeries"><a href="#runPromisesInSeries" class="headerlink" title="runPromisesInSeries"></a>runPromisesInSeries</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> runPromisesInSeries = <span class="function"><span class="params">ps</span> =&gt;</span> ps.reduce(<span class="function">(<span class="params">p, next</span>) =&gt;</span> p.then(next), <span class="built_in">Promise</span>.resolve());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">d</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(r, d));</span><br><span class="line">runPromisesInSeries([<span class="function"><span class="params">()</span> =&gt;</span> delay(<span class="number">1000</span>), () =&gt; delay(<span class="number">2000</span>)]); </span><br><span class="line"><span class="comment">// Executes each promise sequentially, taking a total of 3 seconds to complete</span></span><br></pre></td></tr></tbody></table></figure><p>作用：按照正序 运行给定的多个返回类型为 Promise 函数。</p><p>解析：使用<code>reduce</code>创建一个 Promise 链，每次运行完一个传入的 Promise，都会返回最外部的<code>Promise.then</code>，从而进行下一次调用。</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sleepyWork</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I'm going to sleep for 1 second."</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I woke up after 1 second.'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>作用: 延迟异步函数的执行。</p><p>解析：创建一个接受毫秒数的函数，并结合<code>setTimeout</code>，在给定的毫秒数后，返回一个<code>resolve</code>状态的 Promise。</p><p>使用场景：利用异步函数的“同步”机制(await)，使其在异步函数中达到“睡眠”的效果。</p><h4 id="spreadOver"><a href="#spreadOver" class="headerlink" title="spreadOver"></a>spreadOver</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spreadOver = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">argsArr</span> =&gt;</span> fn(...argsArr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayMax = spreadOver(<span class="built_in">Math</span>.max);</span><br><span class="line">arrayMax([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><p>作用：将接受可变参数的函数更改为接受数组。</p><p>如果你认真读了文章，就会发现这是<code>collectInto</code>函数的反模式。</p><p>分析：利用了扩展运算符的性质，将传递进来的数组解构再交给处理函数。</p><h4 id="times"><a href="#times" class="headerlink" title="times"></a>times</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> times = <span class="function">(<span class="params">n, fn, context = <span class="literal">undefined</span></span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (fn.call(context, i) !== <span class="literal">false</span> &amp;&amp; ++i &lt; n) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> output = <span class="string">''</span>;</span><br><span class="line">times(<span class="number">5</span>, i =&gt; (output += i));</span><br><span class="line"><span class="built_in">console</span>.log(output); <span class="comment">// 01234</span></span><br></pre></td></tr></tbody></table></figure><p>作用：将给定的函数，迭代执行 n 次。</p><p>分析：使用<code>Function.call</code>迭代调用给定的函数，并把迭代的次数传进函数第一个参数。</p><p>如果函数返回 false 可提前退出。</p><h4 id="uncurry"><a href="#uncurry" class="headerlink" title="uncurry"></a>uncurry</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uncurry = <span class="function">(<span class="params">fn, n = <span class="number">1</span></span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function"><span class="params">acc</span> =&gt;</span> <span class="function"><span class="params">args</span> =&gt;</span> args.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x(y), acc);</span><br><span class="line">  <span class="keyword">if</span> (n &gt; args.length) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'Arguments too few!'</span>);</span><br><span class="line">  <span class="keyword">return</span> next(fn)(args.slice(<span class="number">0</span>, n));</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> <span class="function"><span class="params">z</span> =&gt;</span> x + y + z;</span><br><span class="line"><span class="keyword">const</span> uncurriedAdd = uncurry(add, <span class="number">3</span>);</span><br><span class="line">uncurriedAdd(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></tbody></table></figure><p>作用：函数反柯里化。</p><p>柯里化是将接受多个<a href="https://zh.wikipedia.org/wiki/參數_(程式設計" target="_blank" rel="external nofollow noopener noreferrer">参数</a>)的<a href="https://zh.wikipedia.org/wiki/函数" target="_blank" rel="external nofollow noopener noreferrer">函数</a>变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p><p>而反柯里化就是将多个接受参数的层层函数，铺平。</p><p>解析：反柯里化的关键代码在于 <code>args.reduce((x, y) =&gt; x(y), acc)</code>。</p><figure class="highlight gml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在上例中,</span><br><span class="line">args: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">acc: <span class="symbol">x</span> =&gt; <span class="symbol">y</span> =&gt; z =&gt; <span class="symbol">x</span> + <span class="symbol">y</span> + z</span><br><span class="line"></span><br><span class="line">第一次循环：</span><br><span class="line"><span class="symbol">x</span>：<span class="symbol">x</span> =&gt; <span class="symbol">y</span> =&gt; z =&gt; <span class="symbol">x</span> + <span class="symbol">y</span> + z</span><br><span class="line"><span class="symbol">y</span>：<span class="number">1</span></span><br><span class="line">返回结果：<span class="symbol">y</span> =&gt; z =&gt; <span class="number">1</span> + <span class="symbol">y</span> + z</span><br><span class="line"></span><br><span class="line">第二次循环:</span><br><span class="line"><span class="symbol">x</span>: <span class="symbol">y</span> =&gt; z =&gt; <span class="number">1</span> + <span class="symbol">y</span> + z</span><br><span class="line"><span class="symbol">y</span>: <span class="number">2</span></span><br><span class="line">返回结果：z =&gt; <span class="number">1</span> + <span class="number">2</span> + z</span><br><span class="line"></span><br><span class="line">最后一次循环的结果，即 <span class="number">1</span> + <span class="number">2</span> +<span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>可以看出，每次一循环，都会利用闭包”填充”一个所需变量。</p><p>返回的结果分为两种情况：</p><p>一是 一个保留了 n 个前置参数的函数。</p><p>二是层叠函数中最后一个函数的返回结果。</p><p>值得一提的是，在源码中使用了<code>slice(0，n)</code>保留适当数量的参数。</p><p>如果提供的参数的个数小于给定的解析长度，就会抛出错误。</p><h4 id="unfold"><a href="#unfold" class="headerlink" title="unfold"></a>unfold</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unfold = <span class="function">(<span class="params">fn, seed</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> result = [],</span><br><span class="line">    val = [<span class="literal">null</span>, seed];</span><br><span class="line">  <span class="keyword">while</span> ((val = fn(val[<span class="number">1</span>]))) result.push(val[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">n</span> =&gt;</span> (n &gt; <span class="number">50</span> ? <span class="literal">false</span> : [-n, n + <span class="number">10</span>]);</span><br><span class="line">unfold(f, <span class="number">10</span>); <span class="comment">// [-10, -20, -30, -40, -50]</span></span><br></pre></td></tr></tbody></table></figure><p>作用：使用种子值以及特殊的数据存储与迭代方式构建一个数组。</p><p>解析: 我为什么说数据存储与迭代方式很特殊呢？</p><p>迭代的变量与结果值，保存在同一数组里，用 01 下标区分。</p><p>而迭代的函数，也需要满足这一规范，返回同样的数组[value，nextSeed]，保证下一次迭代，或者返回 false 终止过程。</p><h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> when = <span class="function">(<span class="params">pred, whenTrue</span>) =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> (pred(x) ? whenTrue(x) : x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doubleEvenNumbers = when(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span>, x =&gt; x * <span class="number">2</span>);</span><br><span class="line">doubleEvenNumbers(<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line">doubleEvenNumbers(<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>作用：根据<code>pred</code>函数测试给定数据。如结果为真，则执行<code>whenTrue</code>函数；反之，返回数据。</p><p>解析: 我喜欢语义化的封装，可大幅提升代码的可读性，减少逻辑负担。</p><h3 id="专家级"><a href="#专家级" class="headerlink" title="专家级"></a>专家级</h3><h4 id="memoize"><a href="#memoize" class="headerlink" title="memoize"></a>memoize</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoize = <span class="function"><span class="params">fn</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">const</span> cached = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> cache.has(val) ? cache.get(val) : cache.set(val, fn.call(<span class="keyword">this</span>, val)) &amp;&amp; cache.get(val);</span><br><span class="line">  };</span><br><span class="line">  cached.cache = cache;</span><br><span class="line">  <span class="keyword">return</span> cached;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// See the `anagrams` snippet.</span></span><br><span class="line"><span class="keyword">const</span> anagramsCached = memoize(anagrams);</span><br><span class="line">anagramsCached(<span class="string">'javascript'</span>); <span class="comment">// takes a long time</span></span><br><span class="line">anagramsCached(<span class="string">'javascript'</span>); <span class="comment">// returns virtually instantly since it's now cached</span></span><br><span class="line"><span class="built_in">console</span>.log(anagramsCached.cache); <span class="comment">// The cached anagrams map</span></span><br></pre></td></tr></tbody></table></figure><p>作用：为给定的函数添加缓存功能。</p><p>解析: 通过实例化一个新的<code>Map</code>对象来创建一个空的缓存。</p><p>并对函数的调用进一步的封装，如果调用时，传入了一个之前已经传递过的参数，将从缓存中直接返回结果，执行时间为 O(1)；如果是首次传递，则需运行函数，将得到结果缓存，并返回。</p><p>其实，我们还可以借助这个片段，看到一丝 JavaScript 语法的残缺。</p><p>到目前为止，一个社区公认的私有属性语法都没有，TC39 一直提议用<code>#</code>号，并阐述了很多原因、声明。</p><p>哎，说白了，就是 JavaScript 从一开始设计的失误，到现在已经无法挽回了。</p><h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, wait</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> inThrottle, lastFn, lastTime;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (!inThrottle) {</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      lastTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      inThrottle = <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      clearTimeout(lastFn);</span><br><span class="line">      lastFn = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Date</span>.now() - lastTime &gt;= wait) {</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">          lastTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        }</span><br><span class="line">      }, <span class="built_in">Math</span>.max(wait - (<span class="built_in">Date</span>.now() - lastTime), <span class="number">0</span>));</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">'resize'</span>,</span><br><span class="line">  throttle(<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.innerWidth);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.innerHeight);</span><br><span class="line">  }, <span class="number">250</span>)</span><br><span class="line">); <span class="comment">// Will log the window dimensions at most every 250ms</span></span><br></pre></td></tr></tbody></table></figure><p>作用: 函数节流。</p><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5" target="_blank" rel="external nofollow noopener noreferrer">什么是防抖和节流？有什么区别？如何实现？</a> 一文中关于防抖解释：</p><blockquote><p>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率。</p></blockquote><p>同样，节流也是面试必考的点。</p><p>解析：第一次执行时，立即执行给定函数，保存当前的时间，并设置标记变量。</p><p>标记变量主要用于判断是否第一次调用，如果是第一次则立刻运行。</p><p>反之不是第一次运行，过了等待的毫秒后才可继续运行。</p><p>主要逻辑是每次运行前先清除上一个的定时器，然后计算出上一次运行的时间与给定的运行间隔所差的毫秒数，并利用其数据新建一个定时器运行。</p><p>定时器里的函数除了调用给定函数，还会更新上一次运行的时间变量。</p><p>节流的实现，网上的文章有很多版本，但多少都有点瑕疵。</p><hr><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>呼，花了很长的时间，终于搞定了这篇文章。</p><p>以后的 30s 源码刨析系列会挑选一些源码片段去解析，而不是针对某一分类了。</p><p>本篇文章涉及了我的一些思考，希望能对你有帮助。</p><p>转载本站文章请注明作者和出处 <a href="http://tomotoes.com">一个坏掉的番茄</a>，请勿用于任何商业用途。</p><style>.post-toc{overflow-y: auto; overflow-x: hidden; height: 35em;}</style></div><blockquote class="post-copyright"><div class="content"> <span class="post-time">最后更新：<time datetime="2021-02-14T17:22:36.301Z">2021-02-15 01:22:36</time></span> 原文链接：<a href="/blog/30s-javascript-function/" target="_blank" rel="external">https://tomotoes.com/blog/30s-javascript-function/</a></div><footer><div> <img itemprop="image" lass="copyimg" src="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/avatar.jpg" alt="Simon Ma"> <a itemprop="author" itemscope itemtype="http://schema.org/Person" href="/blog">Simon Ma</a></div></footer></blockquote><div class="page-reward"><nav class="inner-reward"> <a id="rewardBtn" href="javascript:;"><span>打&nbsp;赏</span> <span>装成好像很多人打赏的样子</span></a></nav></div><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close2 custom-close"></i></a><br><h3 class="reward-title"><i class="icon icon-quote-left custom-quote-left"></i> <span>感谢您的鼓励支持！</span><i class="icon icon-quote-right custom-quote-right"></i></h3><div class="reward-content"><div class="reward-code"> <img id="rewardCode" src="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/dog.png" data-wechat="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/wechat.png" data-alipay="https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/alipay.png" alt="打赏二维码"></div> <label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" aria-label="reward"><div class="reward-toggle-ctrol"> <span class="reward-toggle-item wechatPay">&nbsp;&nbsp;微信&nbsp;&nbsp;</span> <span class="reward-toggle-item alipayPay">支付宝</span></div></label><i class="icon icon-caretup custom-caret-up"></i></div></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/" rel="tag">函数式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="facebook share-sns" rel="external nofollow noopener noreferrer" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://tomotoes.com/blog/30s-javascript-function/" title="Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" rel="external nofollow noopener noreferrer" target="_blank" href="https://twitter.com/intent/tweet?text=《30s 源码刨析系列之函数篇》 — 一个坏掉的番茄&url=https://tomotoes.com/blog/30s-javascript-function/&via=https://tomotoes.com/blog" title=" Twitter"><i class="icon icon-twitter"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/blog/no-sense/" id="post-prev" class="post-nav-link"><h4 class="title"> 上一篇：无言</h4></a></div><div class="waves-block waves-effect next"><a href="/blog/build-static-site-generator-nodejs/" id="post-next" class="post-nav-link"><h4 class="title" data-hover="下一篇：手撸一个静态文档生成器[译]">下一篇：手撸一个静态文档生成器[译]</h4></a></div></nav><section class="comments" id="comments"><div class="comment-tips">因不可抗拒因素，麻烦站在墙外交流~</div><div id="disqus_thread"></div></section></article></div></main><div class="bgheader"><div id="header-hero"></div></div><template id="cube-template"><div class="cube fade"><div class="shadow"></div><div class="sides"><div class="back"></div><div class="top"></div><div class="left"></div><div class="front"></div><div class="right"></div><div class="bottom"></div></div></div></template><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="fade-scale waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevronup"></span></a><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item waves-block waves-effect" onclick="location.href='{path}'"><div class="title ellipsis" title="{title}">{title}</div></li></template><div id="color-picker" class="page-modal"><a class="close" href="javascript:;"><i class="icon icon-close2"></i></a><br><h4><i class="icon icon-quote-left"></i> <span>自定义主题颜色</span><i class="icon icon-quote-right"></i></h4><div id="color-picker-container"></div></div><script src="https://tomotoes.com/registerSW.js?v=2705cb8a04462"></script><script src="https://cdn.jsdelivr.net/gh/Tomotoes/js/log.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/headroom.js@0.12.0/dist/headroom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5.2.3/dist/iro.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/js/main-e8e4c55efc.js"></script><script src="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/js/script-f65677cca0.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/js/module/post-72698b6b60.js"></script><script defer src="https://cdn.jsdelivr.net/gh/Tomotoes/blog@2705cb8a04462/js/module/comment-bbb0691887.js"></script><script defer src="https://cdn.jsdelivr.net/gh/Tomotoes/js/translate-ff7607fcb8.js"></script></body></html>